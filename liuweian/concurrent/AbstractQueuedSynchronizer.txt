static final class Node {
	// 标记节点正在共享模式下等待的标记
	static final Node SHARED = new Node();
	
	// 标记节点正在以独占模式等待的标记
	static final Node EXCLUSIVE = null;

	// waitStatus = 1；节点由于超时或者中断了被取消了。节点进入了CANCELLED状态之后，就不会再发生状态的变化了。特别地，处于CANCELLED状态节点的线程不会再被阻塞了。
	static final int CANCELLED =  1;
	
	// waitStatus = -1；该节点的后继节点当前是阻塞的，因此当前节点在释放和取消之后，必须唤醒它的后继节点。为了避免竞争，acquire方法必须首先进入SIGNAL等着状态，然后再尝试原子获取，这个获取过程可能会失败或者阻塞。
	static final int SIGNAL    = -1;
	
	// waitStatus = -2；该节点当前处于一个条件队列中。经过转移之后，该节点将会被作为同步队列的节点使用，此时节点的状态会被设置为0。
	static final int CONDITION = -2;
	
	// waitStatus = -3；releaseShared方法应该传递给其他Node节点。在doReleaseShared方法中，确保传递会继续。
	static final int PROPAGATE = -3;

	// 
	volatile int waitStatus;

	// 该节点的前驱节点
	volatile Node prev;

	// 该节点的后继节点
	volatile Node next;

	// 入队列时的当前线程。
	volatile Thread thread;

	// 存储condition队列中的后继节点。
	Node nextWaiter;


	// 默认是共享模式。
	Node() {    
	}

	Node(Thread thread, Node mode) {     
		this.nextWaiter = mode;
		this.thread = thread;
	}

	Node(Thread thread, int waitStatus) {
		this.waitStatus = waitStatus;
		this.thread = thread;
	}

	// 判断当前节点是否是共享模式。
	final boolean isShared() {
		return nextWaiter == SHARED;
	}

	// 获取当前节点的前驱节点。
	final Node predecessor() throws NullPointerException {
		Node p = prev;
		if (p == null) {
			throw new NullPointerException();
		} else {
			return p;
		}
			
	}	
}







public class ConditionObject implements Condition, java.io.Serializable {

	private static final long serialVersionUID = 1173984872572414699L;
	
	// condition队列的第一个节点
	private transient Node firstWaiter;
	
	// condition队列的最后一个节点
	private transient Node lastWaiter;

	public ConditionObject() {
	}

	// 向condition队列中添加节点。
	private Node addConditionWaiter() {
		Node t = lastWaiter;
		
		// 最后一个节点不为null并且状态不等于CONDITION
		if (t != null && t.waitStatus != Node.CONDITION) {
			// 清空condition队列中节点状态不为 CONDITION 的节点
			unlinkCancelledWaiters();
			t = lastWaiter;
		}
		
		// 创建一个状态为CONDITION状态的节点
		Node node = new Node(Thread.currentThread(), Node.CONDITION);
		
		// 如果condition队列的最后一个节点是否为null。把新节点放到condition队列的最后。
		if (t == null) {
			firstWaiter = node;
		} else {
			t.nextWaiter = node;
		}
		lastWaiter = node;
		return node;
	}


	private void doSignal(Node first) {
		do {
			if ( (firstWaiter = first.nextWaiter) == null) {
				lastWaiter = null;
			}
			first.nextWaiter = null;
		} while (!transferForSignal(first) && (first = firstWaiter) != null);
	}

	
	private void doSignalAll(Node first) {
		lastWaiter = firstWaiter = null;
		do {
			Node next = first.nextWaiter;
			first.nextWaiter = null;
			transferForSignal(first);
			first = next;
		} while (first != null);
	}
	
	// 清空condition队列中节点状态不为 CONDITION 的节点
	private void unlinkCancelledWaiters() {
		Node t = firstWaiter;
		Node trail = null;
		
		// 
		while (t != null) {
			Node next = t.nextWaiter;
			if (t.waitStatus != Node.CONDITION) {
				t.nextWaiter = null;
				if (trail == null) {
					firstWaiter = next;
				} else {
					trail.nextWaiter = next;
				}
				if (next == null) {
					lastWaiter = trail;
				}
			} else {
				trail = t;
			}
			t = next;
		}
	}

	
	public final void signal() {
		if (!isHeldExclusively()) {
			throw new IllegalMonitorStateException();
		}
		Node first = firstWaiter;
		if (first != null) {
			doSignal(first);
		}
	}

	
	public final void signalAll() {
		if (!isHeldExclusively()) {
			throw new IllegalMonitorStateException();
		}
		Node first = firstWaiter;
		if (first != null) {
			doSignalAll(first);
		}
	}

	
	public final void awaitUninterruptibly() {
		Node node = addConditionWaiter();
		int savedState = fullyRelease(node);
		boolean interrupted = false;
		while (!isOnSyncQueue(node)) {
			LockSupport.park(this);
			if (Thread.interrupted()) {
				interrupted = true;
			}
		}
		if (acquireQueued(node, savedState) || interrupted) {
			selfInterrupt();
		}
	}

	
	private static final int REINTERRUPT =  1;
	
	private static final int THROW_IE    = -1;

	
	private int checkInterruptWhileWaiting(Node node) {
		return Thread.interrupted() ? (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) : 0;
	}

	
	private void reportInterruptAfterWait(int interruptMode)
		throws InterruptedException {
		if (interruptMode == THROW_IE) {
			throw new InterruptedException();
		} else if (interruptMode == REINTERRUPT) {
			selfInterrupt();
		}
	}

	public final void await() throws InterruptedException {
		// 判断线程是否中断
		if (Thread.interrupted()) {
			throw new InterruptedException();
		}
		
		// 向condition队列中添加节点。
		Node node = addConditionWaiter();
		int savedState = fullyRelease(node);
		int interruptMode = 0;
		while (!isOnSyncQueue(node)) {
			LockSupport.park(this);
			if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
				break;
		}
		if (acquireQueued(node, savedState) && interruptMode != THROW_IE) {
			interruptMode = REINTERRUPT;
		}
		if (node.nextWaiter != null) {
			unlinkCancelledWaiters();
		}
		if (interruptMode != 0) {
			reportInterruptAfterWait(interruptMode);
		}
	}

	public final long awaitNanos(long nanosTimeout) throws InterruptedException {
		if (Thread.interrupted()) {
			throw new InterruptedException();
		}
		
		Node node = addConditionWaiter();
		int savedState = fullyRelease(node);
		final long deadline = System.nanoTime() + nanosTimeout;
		int interruptMode = 0;
		while (!isOnSyncQueue(node)) {
			if (nanosTimeout <= 0L) {
				transferAfterCancelledWait(node);
				break;
			}
			if (nanosTimeout >= spinForTimeoutThreshold) {
				LockSupport.parkNanos(this, nanosTimeout);
			}
			if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) {
				break;
			}
			nanosTimeout = deadline - System.nanoTime();
		}
		if (acquireQueued(node, savedState) && interruptMode != THROW_IE) {
			interruptMode = REINTERRUPT;
		}
		if (node.nextWaiter != null) {
			unlinkCancelledWaiters();
		}
		if (interruptMode != 0) {
			reportInterruptAfterWait(interruptMode);
		}
		return deadline - System.nanoTime();
	}

	public final boolean awaitUntil(Date deadline) throws InterruptedException {
		long abstime = deadline.getTime();
		if (Thread.interrupted()) {
			throw new InterruptedException();
		}
		Node node = addConditionWaiter();
		int savedState = fullyRelease(node);
		boolean timedout = false;
		int interruptMode = 0;
		while (!isOnSyncQueue(node)) {
			if (System.currentTimeMillis() > abstime) {
				timedout = transferAfterCancelledWait(node);
				break;
			}
			LockSupport.parkUntil(this, abstime);
			if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) {
				break;
			}
		}
		if (acquireQueued(node, savedState) && interruptMode != THROW_IE) {
			interruptMode = REINTERRUPT;
		}
		if (node.nextWaiter != null) {
			unlinkCancelledWaiters();
		}
		if (interruptMode != 0) {
			reportInterruptAfterWit(interruptMode);
		}
		return !timedout;
	}

	
	public final boolean await(long time, TimeUnit unit) throws InterruptedException {
		long nanosTimeout = unit.toNanos(time);
		if (Thread.interrupted()) {
			throw new InterruptedException();
		}
		Node node = addConditionWaiter();
		int savedState = fullyRelease(node);
		final long deadline = System.nanoTime() + nanosTimeout;
		boolean timedout = false;
		int interruptMode = 0;
		while (!isOnSyncQueue(node)) {
			if (nanosTimeout <= 0L) {
				timedout = transferAfterCancelledWait(node);
				break;
			}
			if (nanosTimeout >= spinForTimeoutThreshold) {
				LockSupport.parkNanos(this, nanosTimeout);
			}
			if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) {
				break;
			}
			nanosTimeout = deadline - System.nanoTime();
		}
		
		if (acquireQueued(node, savedState) && interruptMode != THROW_IE) {
			interruptMode = REINTERRUPT;
		}
		
		if (node.nextWaiter != null) {
			unlinkCancelledWaiters();
		}
		
		if (interruptMode != 0) {
			reportInterruptAfterWait(interruptMode);
		}
		return !timedout;
	}


	final boolean isOwnedBy(AbstractQueuedSynchronizer sync) {
		return sync == AbstractQueuedSynchronizer.this;
	}

	
	protected final boolean hasWaiters() {
		if (!isHeldExclusively()) {
			throw new IllegalMonitorStateException();
		}
		for (Node w = firstWaiter; w != null; w = w.nextWaiter) {
			if (w.waitStatus == Node.CONDITION)
				return true;
		}
		return false;
	}


	protected final int getWaitQueueLength() {
		if (!isHeldExclusively()) {
			throw new IllegalMonitorStateException();
		}
		int n = 0;
		for (Node w = firstWaiter; w != null; w = w.nextWaiter) {
			if (w.waitStatus == Node.CONDITION) {
				++n;
			}
		}
		return n;
	}

	protected final Collection<Thread> getWaitingThreads() {
		if (!isHeldExclusively()) {
			throw new IllegalMonitoStateException();
		}
		ArrayList<Thread> list = new ArrayList<Thread>();
		for (Node w = firstWaiter; w != null; w = w.nextWaiter) {
			if (w.waitStatus == Node.CONDITION) {
				Thread t = w.thread;
				if (t != null) {
					list.add(t);
				}
			}
		}
		return list;
	}
}


// 这是AbstractQueuedSynchronized。
// release【/rɪˈliːs/】：释放；放开；发泄；免除；松开；使不紧张；
final int fullyRelease(Node node) {
	boolean failed = true;
	try {
		// 获取当前AQS的状态的状态
		int savedState = getState();
		if (release(savedState)) {
			failed = false;
			return savedState;
		} else {
			throw new IllegalMonitorStateException();
		}
	} finally {
		if (failed) {
			node.waitStatus = Node.CANCELLED;
		}
	}
}

// 释放。
public final boolean release(int arg) {
	if (tryRelease(arg)) {
		Node h = head;
		if (h != null && h.waitStatus != 0) {
			unparkSuccessor(h);
		}
		return true;
	}
	return false;
}

// 留给子类去重写。
protected boolean tryRelease(int arg) {
	throw new UnsupportedOperationException();
}











