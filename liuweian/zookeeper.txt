什么是分布式系统：
	分布式系统：多个【不同的服务】联系起来做一件事。比如一次完整的购物过程：
	
分布式系统带来的问题：
	（1）分布式服务框架
		你如果要让不同的子系统或者服务之间互相通信，首先必须有一套分布式服务框架。也就是各个服务可以互相感知到对方在哪里，可以发送请求过去，
		可以通过HTTP或者RPC的方式。在这里，最常见的技术就是dubbo以及spring cloud，当然大厂一般都是自己有服务框架

	（2）分布式事务
		一旦你的系统拆分为了多个子系统之后，那么一个贯穿全局的分布式事务应该怎么来实现？
		这个你需要了解TCC、最终一致性、2PC等分布式事务的实现方案和开源技术。

	（3）分布式锁
		不同的系统之间如果需要在全局加锁获取某个资源的锁定，此时应该怎么来做？
		毕竟大家不是在一个JVM里了，不可能用synchronized来在多个子系统之间实现锁吧，是不是？

	（4）分布式缓存
		如果你原来就是个单块系统，那么你其实是可以在单个JVM里进行本地缓存就可以了，比如搞一个HashMap来缓存一些数据。
		但是现在你有很多个子系统，他们如果要共享一个缓存，你应该怎么办？是不是需要引入Redis等缓存系统？

	（5）分布式消息系统
		在单块系统内，就一个JVM进程内部，你可以用类似LinkedList之类的数据结构作为一个本地内存里的队列。
		但是多个子系统之间要进行消息队列的传递呢？那是不是要引入类似RabbitMQ之类的分布式消息中间件？

	（6）分布式搜索系统
		如果在单块系统内，你可以比如在本地就基于Lucene来开发一个全文检索模块，但是如果是分布式系统下的很多子系统，你还能直接基于Lucene吗？
		明显不行，你需要在系统里引入一个外部的分布式搜索系统，比如Elasticsearch。

	（7）其他很多的技术
		比如说分布式配置中心、分布式日志中心、分布式监控告警中心、分布式会话，等等，都是分布式系统场景下你需要使用和了解的一些技术。
	
	
	
	
ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务
	配置管理、命名服务、分布式锁、集群管理。

zookeeper命令：
	connect host:port

	ls path [watch]
		查看path路径下的内容。如果需要监听节点和子节点的变化，可以使用watch命令。
		
	ls2 path [watch]
		ls2相当于ls + get命令，
	
	create [-s] [-e] path data acl
		create创建一个节点。默认创建持久化节点。
			-s：表示顺序节点
			-e：表示临时节点，在客户端退出以后会自定删除。	
		acl：用于设置权限的。
	
	
	delete path [version]
		删除路径和节点。如果这个节点有子节点，是无法删除的。
		
	rmr path
		删除路径。如果有子节点，会递归删除所有节点。
		
	
	get path [watch]
		获取节点的相关信息。
			cZxid = 0x8                                     是节点的创建时间所对应的Zxid格式时间戳
			ctime = Tue Nov 19 10:42:07 CST 2019            是节点的创建时间
			mZxid = 0x8                                     是节点的修改时间所对应的Zxid格式时间戳。
			mtime = Tue Nov 19 10:42:07 CST 2019            是节点的修改时间
			pZxid = 0x8                                     是与该节点的子节点（或该节点）的最近一次创建/删除的时间戳对应。
			cversion = 0                                    子版本号
			dataVersion = 0                                 数据版本号
			aclVersion = 0                                  权限版本号
			ephemeralOwner = 0x0                            如果该节点为ephemeral节点, ephemeralOwner值表示与该节点绑定的session_id. 如果该节点不是ephemeral节点, ephemeralOwner值为0. 
			dataLength = 11                                 数据长度
			numChildren = 0                                 子节点的个数。
		
	stat path [watch]
		和get命令大体相同。
	
	set path data [version]
		设置指定的znode节点的信息。
		这个version是dataVersion的版本，如果指定的版本和znode的现在的版本不一致，是无法修改数据的。
		
	
	setquota -n|-b val path
		设置配额，配额分为两种，一种是对子节点数量的限制，称之为count限制，一种是对节点能够存放的数据大小的限制，称之为byte限制。
			-n 限制此节点最大可拥有多少个子节点。这个只算孩子节点，孙子及其以后的节点不统计。
			-b 限制此节点能够存储的数据最大是多少个字节
	
	listquota path
		查看配置。
	
	delquota [-n|-b] path
		产出配额。
		
	
	setAcl命令
		设置节点Acl。acl由大部分组成：1为scheme，2为user，3为permission，一般情况下表示为scheme:id:permissions。其中scheme和id是相关的，下面将scheme和id一起说明。
		scheme和id
			world: 它下面只有一个id, 叫anyone, world:anyone代表任何人，zookeeper中对所有人有权限的结点就是属于world:anyone的
			auth: 它不需要id, 只要是通过authentication的user都有权限（zookeeper支持通过kerberos来进行authencation, 也支持username/password形式的authentication)
			digest: 它对应的id为username:BASE64(SHA1(password))，它需要先通过username:password形式的authentication
			ip: 它对应的id为客户机的IP地址，设置的时候可以设置一个ip段，比如ip:192.168.1.0/16, 表示匹配前16个bit的IP段
			super: 在这种scheme情况下，对应的id拥有超级权限，可以做任何事情(cdrwa)

			permissions
				CREATE(c): 创建权限，可以在在当前node下创建child node
				DELETE(d): 删除权限，可以删除当前的node
				READ(r): 读权限，可以获取当前node的数据，可以list当前node所有的child nodes
				WRITE(w): 写权限，可以向当前node写数据
				ADMIN(a): 管理权限，可以设置当前node的permission

		综上，一个简单使用setAcl命令，则可以为：
			setAcl /zookeeper/node1 world:anyone:cdrw

	addauth scheme auth
	
	setAcl path acl
	
	getAcl path
		
	
	quit
		退出客户端。
		
	history
		查看最近的操作命令。
	
	close
		关闭本次连接，但是不退出客户端。还可以使用connect命令连接服务端。
	
	printwatches on|off



权限：http://www.manongjc.com/article/88875.html

	查看zookeeper的状态
		sh /bin/zkServer.sh status
	
	配置zookeeper的环境
		vi /bin/zkEvn.sh 





1、介绍一下zookeeper。
	它是一个分布式、开源的分布式应用程序协调服务。是Apache Hadoop的一个子项目，它主要是用来解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务、状态同步服务、
	集群管理、分布式应用配置项的管理等。
	

2、首先要搞懂分布式系统会存在哪些问题？


3、paxos算法原理。
	从二阶段提交到三阶段提交再到paxos算法。
	
	* 当集群中，超过半数的Acceptor接受了一个议案，那我们就可以说这个议案被选定了（Chosen）。
	* 一个Acceptor必须接受它收到的第一个议案。
	
	p1：一个Acceptor必须接受它收到的第一个议案。
	p2：如果编号为M0、value值为V0的提案（即为[M0、V0]）被选定了，那么所有比编号M0更高的，且被选定的提案，其Value值必须也是V0.
	p2a：如果编号为M0、value值为V0的提案（即为[M0、V0]）被选定了，那么所有比编号M0更高的，且被Acceptor选定的提案，其Value值也是V0。
	p2b：如果一个提案[M0、V0]被选定以后，那么之后任何proposer产生的更高编号的提案，其Value都为V0。
	
	paxos算法中proposer如何生成提案，accepter如何批准提案。
		生成提案：Proposer在产生一个编号Mn的提案时，必须要知道当前某一个将要或已经被半数以上Acceptor
			      批准的编号小于Mn但是为最大的编号的提案。并且，Proposer会要求所有的Acceptor都不要在批准
				  任何编号小于Mn的提案。
	
	
4、paxos算法：
	第一阶段：
		* proposer选择一个提案编号Mn,然后向Acceptor的某个超过半数的子集成员发送编号为Mn的Prepare请求。
		* 如果一个Acceptor收到一个编号Mn的Prepare请求，且编号Mn大于该Acceptor已经响应的所有Prepare请求编号
		  那么它就会将它已经批准过的最大编号的提案作为响应反馈给proposer,同时该Acceptor会承诺不会再批准任何
		  编号小于Mn的提案。
		  
	第二阶段:
		* 如果Proposer收到来自半数以上的Acceptor对其发出的编号为Mn的Prepare请求的响应，那么它就会发送一个针对
		  [Mn, Vn]提案的Accept请求给Acceptor。注意，Vn的值就是接收的响应中编号最大的提案的值，如果响应中不包含任何
		  提案，那么它就是任意值。
		  
		* 如果Acceptor收到这个针对[Mn, Vn]提案的Accept请求，只要改Acceptor尚未对编号大于Mn的Prepare请求做出响应，
		它就可以通过这个提案。
	
	
	
崩溃恢复和消息广播
	zkClient、Curator
	
	
5、使用zookeeper实现分布式锁。
	* 获取锁
	首先创建一个持久化节点persistNode，用于表示某一个锁的表示，如果有一个线程需要获取锁，需要在持久化节点persistNode下创建一个临时顺序节点。如果持久化
	节点下没有任何节点，该线程创建的节点为第一个节点，直接获取锁。如果又有其他线程过来获取锁，则继续创建锁，并在前一个临时节点上添加Watch。这样组成了一个
	等待队列。
	当第一个线程结束以后，会删除第一个临时节点，由于第二节点监听第一个节点，当第一节点被删除后，第二节点会立即接收到通知，如此线程二就可以获取到锁。
	
6、比较redis和zookeeper实现分布式锁的优缺点。