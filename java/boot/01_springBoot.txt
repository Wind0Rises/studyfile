1、spring boot如何实现自动化配置。
	@Import(...)：把指定的类导入Spring容器中。【https://blog.csdn.net/pange1991/article/details/81356594】
	@SpringBootConfiguration：
	@EnableAutoConfiguration：

	在传统的spring工程中，如果工程要和数据库整合，需要在XML中配置各种数据源，配置SqlSessionFactoryBean等类。如果使用spring boot开启自动配置，spring boot就会自动帮我
把需要的Bean进行初始化，并放到Spring容器中。
	使用@EnableAutoConfiguration注解，在启动spring boot的时候，spring boot会读取MATE-INF/spring.factories的文件，在spring.factories文件中配置各个注解所对应需要加载的
Bean，key为注解类的全限定名，value为加载类的全限定名，如果有多个需要加载的bean使用逗号隔开。一些常用的类spring boot已经帮我们整理好了，包括jdbc、redis、amqp、web等等。

	引出的问题：
	Spring boot怎么知道配置哪些Bean？？



location：ConfigurationClassPostProcessor
public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {
	int factoryId = System.identityHashCode(beanFactory);

	if (this.factoriesPostProcessed.contains(factoryId)) {
		throw new IllegalStateException("postProcessBeanFactory already called on this post-processor against " + beanFactory);
	}

	this.factoriesPostProcessed.add(factoryId);
	if (!this.registriesPostProcessed.contains(factoryId)) {
		processConfigBeanDefinitions((BeanDefinitionRegistry) beanFactory);
	}

	enhanceConfigurationClasses(beanFactory);

	beanFactory.addBeanPostProcessor(new ImportAwareBeanPostProcessor(beanFactory));
}

location：ConfigurationClassPostProcessor
public void enhanceConfigurationClasses(ConfigurableListableBeanFactory beanFactory) {

	Map<String, AbstractBeanDefinition> configBeanDefs = new LinkedHashMap<>();
	for (String beanName : beanFactory.getBeanDefinitionNames()) {

		// 获取BeanFactory中的BeanDefinition
		BeanDefinition beanDef = beanFactory.getBeanDefinition(beanName);

		// 判断这个Bean是否是完成的Configuration类。
		if (ConfigurationClassUtils.isFullConfigurationClass(beanDef)) {
			if (!(beanDef instanceof AbstractBeanDefinition)) {
				throw new BeanDefinitionStoreException("Cannot enhance @Configuration bean definition '" + beanName + "' since it is not stored in an AbstractBeanDefinition subclass");
			} else if (logger.isInfoEnabled() && beanFactory.containsSingleton(beanName)) {
				logger.info("Cannot enhance @Configuration bean definition '" + beanName + "' since its singleton instance has been created too early. The typical cause " + "is a non-static @Bean method with a BeanDefinitionRegistryPostProcessor " +
						"return type: Consider declaring such methods as 'static'.");
			}

			// 把Config类放入configBeanDefs集合中。
			configBeanDefs.put(beanName, (AbstractBeanDefinition) beanDef);
		}
	}

	if (configBeanDefs.isEmpty()) {
		return;
	}

	// ConfigurationClassEnhancer,它会对应用中每个配置类，也就是一般通过@Configuration注解定义的类进行一个增强。通过增强以后，配置类中使用@Bean注解的bean定义
	// 方法就不再是普通的方法了，它们具有了如下跟bean作用域有关的能力，以单例bean为例 ：
	//		* 它们首次被调用时，相应方法逻辑会被执行用于创建bean实例；
	//		* 再次被调用时，不会再执行创建bean实例，而是根据bean名称返回首次该方法被执行时创建的bean实例。
	ConfigurationClassEnhancer enhancer = new ConfigurationClassEnhancer();
	for (Map.Entry<String, AbstractBeanDefinition> entry : configBeanDefs.entrySet()) {
		AbstractBeanDefinition beanDef = entry.getValue();
		beanDef.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE);
		try {
			// 获取原有的Bean的Class
			Class<?> configClass = beanDef.resolveBeanClass(this.beanClassLoader);
			if (configClass != null) {
				
				// 生成增强型Class
				Class<?> enhancedClass = enhancer.enhance(configClass, this.beanClassLoader);
				if (configClass != enhancedClass) {
					if (logger.isTraceEnabled()) {
						logger.trace(String.format("Replacing bean definition '%s' existing class '%s' with " + "enhanced class '%s'", entry.getKey(), configClass.getName(), enhancedClass.getName()));
					}

					// 把增强型Bean的Class覆盖原有的Class。
					beanDef.setBeanClass(enhancedClass);
				}
			}
		} catch (Throwable ex) {
			throw new IllegalStateException("Cannot load configuration class: " + beanDef.getBeanClassName(), ex);
		}
	}
}