# HashMap与ConcurrentHashMap

## 一、HashMap

### 1.1  JDK1.7中的HashMap

#### 1.1.1 HashMap#put()的流程。

1. 首先判断HashMap的内部数组是否是空的，如果是空的，首先要初始化数组。
2. 判断put操作的Key是否为null，如果为null，进行key为null的put操作。
3. **计算Key对应的Hash值**，并计算出给定key对应的内部数组的位置。**[如何计算内部数组的位置](#如何计算内部数组的位置)**
4. 遍历内部数组位置上的元素，判断该Key对应的元素是否存在，如果存在，更新为传进来的新值，并把老值返回回去。
5. 判断是否需要扩展，如果需要扩容进行扩容操作。**如何判断是否需要扩容的**
6. 构建一个新的Entry元素，并把元素添加进去。首先判断对应数组位置上是否存在元素，如果不存在元素，直接把这个新的Entry放在这个数组上，如果位置上存在元素，则把新的Entry元素的next指向已经存在数组位置上的老的Entry元素，并把自己放在数组位置上。


#### 1.1.2 <a id="如何计算内部数组的位置">为什么HashMap的数组容量是2的幂次方</a>

这个问题可以解决如何计算内部数组的位置。

``` java
假设一个key的hash值的二进制位：1010 0101；内部数组的长度为16， 二进制表示为0001 0000   
hash	: 1010 0101
length 	: 0001 0000
```



#### 1.1.3 头插法和尾插法

#### 1.1.4 如何计算key对应的hashcode

#### 1.1.5 如何确定key对应数组的位置？取余？？

### 1.2 JDK1.8中的HashMap



### 1.3 HahsMap的存在的问题

* 线程不安全的？在哪里不安全？？



## 二、ConcurrentHashMap

### 2.1



## 三、其他问题

### 3.1 为什么HashMap的key可以为null但是ConcurrentHashMap的值不能为null。
