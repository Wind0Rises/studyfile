局部变量表用的是索引，，操作数栈是弹栈/压栈来访问
https://blog.csdn.net/qq_28666081/article/details/85269879


1、jvm虚拟机栈的结构。
	每一个现在开始时，都会创建一个虚拟机栈，用于保存线程运行时的数据。jvm虚拟机栈，是由一个个栈帧组成。栈帧是由局部变量表（方法的参数，内部使用的变量）、操作数栈、
	动态链接、方法出口。

2、什么是操作数栈。
	操作数：运算符操作的实体，
	操作数栈：用于保存和运算操作数的栈，有压栈和弹出栈两个操作。
	
3、什么是动态链接。

4、方法区：
	方法区主要用于存储已被jvm加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
	
	jdk7及其以前：分为新生代[eden、survivor、survivor]、老年代、永久代。
	jdk8及其以后：取消了永久代使用元空间进行代替。
	
	为什么取消永久代，使用元空间代替？
		jdk1.7及其以前永久代默认情况下空间比较小，字符串存在永久代，容易出现性能问题和内存溢出。
		类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代(就小了）溢出。
	
5、方法区和永久代
	方法区是JVM的规范，永久代是HotSpot的一种实现，在HotSpot虚拟机上我们习惯把方法区成为永久代。
	
	
6、逃逸分析算法
	当变量（或者对象）在方法中分配后，其指针有可能被返回或者被全局引用，这样就会被其他方法或者线程所引用，这种现象称作指针（或者引用）的逃逸(Escape)。
	通俗点讲，如果一个对象的指针被多个方法或者线程引用时，那么我们就称这个对象的指针发生了逃逸。
	
	为了减少临时对象在堆内分配的数量，我会在一个方法体内定义一个局部变量，并且该变量在方法执行过程中未发生逃逸，按照JVM调优机制，首先会在堆内存创建类的实例，
	然后将此对象的引用压入调用栈，继续执行，这是JVM优化前的方式。然后，我采用逃逸分析对JVM进行优化。即针对栈的重新分配方式，首先找出未逃逸的变量，
	将该变量直接存到栈里，无需进入堆，分配完成后，继续调用栈内执行，最后线程执行结束，栈空间被回收，局部变量也被回收了。如此操作，是优化前在堆中，
	优化后在栈中，从而减少了堆中对象的分配和销毁，从而优化性能。
	
	solt复用（如果局部变量出了作用域，那么后面如果有新的对象被创建solt将被复用，如果没有新对象创建将不会被复用。）、
	在垃圾回收之前如果把对应置为null，这是对象都会被回收、
	
	
	https://blog.csdn.net/qiyue683209/article/details/82961472
	
7、分代收集
	新生代收集器：Serial、ParNew、Parallel Scavenge
	老年代收集器：CMS、Serial Old、Parallel Old
	整堆收集器： G1
	https://www.cnblogs.com/chenpt/p/9803298.html