# JVM基础学习
## 一、JVM的内存结构
### 1.1 JVM内存区域
* 线程独占的：程序计数器、本地方法栈、Java虚拟机栈
* 线程共享的：堆、元空间（java8之前叫方法区）



### 1.2 各个内存区域的作用
#### 1.2.1 程序计数器
程序计数器：可以看做当前线程所执行的字节码的行号指示器，指向下一条指定的地址。因为在虚拟机模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一个需要执行的字节码指令。
#### 1.2.2 Java虚拟机栈
Java虚拟机栈的生命周期是与线程相同的，虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行时都会创建一个栈帧用于存储**局部（本地）变量表、操作数栈、动态链接、方法出口（返回地址）等信息**。每一个方法被调用到执行完成的过程，就会对应一个栈帧在虚拟机栈中入栈和出栈的过程。
#### 1.2.3 本地方法栈
本地方法栈与Java虚拟机栈非常类似，本地方法栈是针对native方法。
#### 1.2.4 Java堆
Java堆：被所有线程共享，在虚拟机启动时就创建，此区域唯一目的就是存放对象实例，**几乎所有**对象实例以及数组都在这里分配内存；
#### 1.2.5 元空间（方法区）
元空间（方法区）：被所有线程所共享，它用于存储已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据

### 1.3 主存、工作空间（TODO）





## 二、JVM垃圾回收
### 2.1 引用
#### 2.1.1 什么是引用
先看一段话：<br/>
"每种编程语言都有自己的数据处理方式。有些时候，程序员必须注意将要处理的数据是什么类型。你是直接操纵元素，还是用某种基于特殊语法的间接表示（例如C/C++里的指针）来操作对象。所有这些在 Java 里都得到了简化，一切都被视为对象。因此，我们可采用一种统一的语法。尽管将一切都“看作”对象，但操纵的标识符实际是指向一个对象的“引用”（reference）。"
这段话来自于《Java编程思想》，很显然，从这段话可以看出对象和对象引用不是一回事，是两个完全不同的概念。举个例子，我们通常会用下面这一行代码来创建一个对象：<br/>

``` java
Person person = new Person("张三");
```
有人会说，这里的person是一个对象，是Person类的一个实例。<br/>
也有人会说，这里的person并不是真正的对象，而是指向所创建的对象的引用。<br/><br/>
到底哪种说法是对的？我们先不急着纠结哪种说法是对的，再看两行代码：
``` java
Person person;
person = new Person("张三");
```
这两行代码实现的功能和上面的一行代码是完全一样的。大家都知道，在Java中new是用来在堆上创建对象用的，如果person是一个对象的话，那么第二行为何还要通过new来创建对象呢？由此可见，person并不是所创建的对象，那是什么呢？上面的一段话说的很清楚，“操纵的标识符实际是指向一个对象的引用”，也就是说person是一个引用，是指向一个可以指向Person类的对象的引用。真正创建对象的语句是右边的new Person("张三");
再看一个例子：<br/>
``` java
Person person;
person = new Person("张三");
person = new Person("李四");
```
这里让person先指向了“张三”这个对象，然后又指向了“李四”这个对象。也就是说，Person person，这句话只是声明了一个Person类的引用，它可以指向任何Person类的实例。这个道理就和下面这段代码一样：
```java
int a;
a = 2;
a = 3;
```
这里先声明了一个int类型的变量a，先对a赋值为2，后面又赋值为3.也就是说int类型的变量a，可以让它的值为2，也可以为3，只要是合法的int类型的数值即可。也就是说，一个引用可以指向多个对象，而一个对象可不可以被多个引用所指呢？答案当然是可以的。比如：
``` java
Person person1 = new Person("张三");
Person person2 = person1;
```
person1和person2都指向了“张三”这个对象。

#### 2.1.2 引用的种类
* 强引用：就是在程序代码之中普遍存在，类似“Object obj = new Object()”这类的引用，只要是强引用还存在，垃圾回收器永远不会回收掉被引用的对象。
* 软引用：软引用用于描述一些还有用，但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中并进行第二次回收。如果这次回收还是没有足够的内存，才会抛出内存溢出的异常。
* 弱引用：弱引用也是用来描述非必需的，但是强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生前。当垃圾回收器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。
* 虚引用：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是希望能在这个对象被回收器回收时收到一个系统通知。
#### 2.1.3 对象的生存与死亡

在可达性分析算法中不可达的对象，也并非是“非死不可”，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。



### 2.2 标记算法
#### 2.2.1 引用计数算法
给对象中添加一个计数器，每当有一个地方引用它时，计数器的值都就加1；当引用失效时，计计数器的值都就减1；任何时刻计数器都为0的对象就是不能再被使用的。**无法解决循环引用问题**
``` java
/**
 * 首先要知道什么是变量：变量的实质是一小块内存单元。这一小块内存里存储着变量的值。
 * 比如 int a = 1;
 * a就是变量的名称，1就是变量的值。
 *
 * 当变量指向一个对象时，这个变量就被称为引用变量
 * 比如 A a = new A(); a就是引用变量，它指向了一个A对象，也可以说它引用了一个A对象。我们通过操纵这个a来操作A对象。 此时，变量a的值为它所引用对象的地址
 *
 * 局部变量：在使用前，必须进行显示赋值，否则编译不通过
 */
public class ReferenceCountingGC {

    public Object instance;

    public static void testGC() {
        ReferenceCountingGC objA = new ReferenceCountingGC(); // step1
        ReferenceCountingGC objB = new ReferenceCountingGC(); // step2

        objA.instance = objB; // step3
        objB.instance = objA; // step4

        objA = null; // step5
        objB = null; // step6

        /**
         * 根据引用计数算法来分析，objA、objB是不会被垃圾回收的，但是实际上是进行了垃圾回收。
         */
        System.ge();
    }
}
```
分析：
* objA对象引用new ReferenceCountingGC();objA引用计数器加1，此时objA的计数器值为1；
* objB对象引用new ReferenceCountingGC();objB引用计数器加1，此时objB的计数器值为1；
* objA.instance指向objB，所以objB的计数器加1，此时objB的计数器值为2；
* objB.instance指向objA，所以objA的计数器加1，此时objA的计数器值为2；
* objA不再指向ReferenceCountingGC()；objA引用计数器减1，此时objA的计数器值为1；
* objB不再指向ReferenceCountingGC()；objB引用计数器减1，此时objB的计数器值为1；



#### 2.2.2 可达性分析法
可达性分析算法：通过一系列名为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。
可作为GC Roots的对象包括：
* 虚拟机栈（栈帧中的本地变量）中的引用的对象。
* 方法区中的类静态属性引用的对象。
* 方法区中的常量引用的对象。
* 本地方法栈中JNI（即一般说的Native方法）的引用的对象。



### 2.3 垃圾回收算法
#### 2.3.1 标记清除算法
首先标记出所有要回收的对象，在标记完成以后统一回收掉所有被标记的对象，<br/>
缺点：<br/>
* 效率问题，标记和清除效率都不高。
* 会产生大量不连续的内存碎片。

### 2.3.2 复制算法
复制算法：可以把内存划分为大小相等的两块，每次只使用其中的一块。当这块内存用完了，就将还存活的对象复制到另一块上面，然后再把已经用过的内存空间一次清理掉。<br/>
缺点：<br>
* 内存使用率只有50%。

### 2.3.3 标记整理

### 2.3.4 分代收集



### 2.4 分代
#### 2.4.1 分代介绍
* java7及其以前版本：堆内存划分三个区域年轻代、老年代、永久代
* java8：堆内存划分年轻代、老年的，去除了永久代，

#### 2.4.2 年轻代介绍
年轻代又被划分三个区域：一个Eden区域、两个Survivor区域。




## 三、垃圾回收器
### 3.1 垃圾回收器介绍
#### 3.1.1 Serial收集器

#### 3.1.2 ParNew收集

### 3.2 垃圾回收器比较
