
一、面试题。
	1)、如何保证缓存与数据库的双写一致性？ 
		把读写操作都写到队列中，然后通过队列进行操作。类似于基于AQS的读写锁的操作。
		
		1、先操作数据，后删除redis中的缓存。如果操作数据成功，异常，这是redis中的数据就是老的数据库。
		2、先删除redis中的缓存，在去修改数据库。如果线程一，成功删除了redis中的数据，这是还没有来的修改数据，这是线程二过来查询，发现redis中没有数据，然后去数据查询并把数据写入redis后，线程一才进行更新操作。
		   这是redis中还是老的数据。
		3、集群的时候。基于nginx的进行hash保证一个key对应的操作都到一个数据库上。
		
		
		解决方案：把所有的增删改操作都封装起来，然后放入到一个队列中【所有的修改操作都是先清除redis缓存，然后在去修改数据库数据。】，对于读如果redis没有对应数据，把这些读数据也封装成一个操作，放入到对应的队列中。
		
	
	
	
	2)、分库分表带来了哪些问题？如何解决的？
		1、分库分表策略？
			* 垂直分表
			* 垂直分库
			* 水平分表
			* 水平分库
			
		2、主键生成策略？
		
		3、分页查询？
		
		
		
		
		
		
	3)、分布式锁的实现方式
		1、分布式锁需满足四个条件：
			* 互斥性（在任意时刻，只有一个客户端能持有锁）。
			* 不会发生死锁。
			* Redis锁的过期时间小于业务的执行时间该如何续期？是加的锁，那么释放就由谁去释放。
			* 具备一定的容错性。
				

		2、使用zookeeper实现分布式锁（zkclient、curator）
			* 首先创建一个持久化节点persistNode，用于表示某一个锁，
			* 如果有一个线程需要获取锁，需要在持久化节点persistNode下创建一个临时顺序节点。如果持久化节点下没有任何节点，该线程创建的节点为第一个节点，直接获取锁。如果又有其他线程过来获取锁，则继续创建临时顺序节点，
			  并在前一个临时节点上添加Watch。这样组成了一个等待队列。【【【临时节点的作用：如果进程异常退出，会直接把临时节点删除。】】】
			* 第一个线程结束以后，会删除第一个临时节点，由于第二节点监听第一个节点，当第一节点被删除后，第二节点会立即接收到通知，如此线程二就可以获取锁。
		
		
		3、使用redis实现分布式锁。Redis锁的过期时间小于业务的执行时间该如何续期？（jedis、redisson、redLock）
			* 使用set key value 时间[px|ex] 模式[nx|xx]
			* 启动一个后台守护线程，每隔一段时间就去查询一下锁是否释放，如果没有释放，自动延长key的时间。（注意key或者value中保存对应的线程，判断是否是要需要的线程和获取锁的线程是否是一个）
			* 释放锁。
			
			
		4、使用数据实现分布式锁。
			* 新增一条数据用于保存一个锁，有数据则有获取锁，
			* 定时任务，删除锁，解决死锁问题
			* 添加线程号字段，可以实现重入锁。
			
		
	
	
	4)、分布式事务的解决方式。
		1、两阶段提交
			常见于一个系统操作中操作多个数据库。
		
		2、TCC方案：try、confirm、cancel
		
		3、本地消息
		
		4、可靠消息最终一致性方案
		
		5、最大努力通知方案
		
		
		
		
	5)、分布式系统session一直性问题。	
	
	
	
	
	6)、redis的线程模式
		* 非堵塞的IO多路复用机制。
		* 基于内存操作的
		* 单线程避免了多线程的频繁上下文切换问题。
		
		
		
	7)、Redis几种数据类型以及使用场景
		* String	保存一个字符串，
		* Hash 		value是一个map，可以保存一个实体对象，
		* List 		可以向java中使用一个队列一样使用queue。
		* Set		value中是一些不重复的字符串，
		* Zset		value中是一些不重复的字符串，并且更具给定的权重排好序的。
		
		
	8)、缓存穿透和缓存雪崩
		1、缓存雪崩
			缓存宕机 ---》 请求全部打到数据上   ---》 缓存高可用
												---》 可以对热定数据做多级缓存
												---》 限流和降级
												---》 做持久化和冷热备份
		
		2、缓存穿透 ---》  恶意使用不存在的key请求		---》	设置key的规制，规制不匹配直接拒绝
													    ---》 	对数据库中没有数据的key也进行缓存，并设置较短的过期时间。
			
		
	9)、为什么要使用消息队列，MQ优缺点。各种MQ的优缺点。
		1、为什么要使用消息队列？
			异步：审批系统不需要同步调用电商进行通知，
			解耦：审批系统不需要依赖电商接口。
			削峰：去哪儿会批量发送申请数据，开户本来耗时就长。
				
			
		2、消息队列有哪些优点和缺点？
			优点：就是你为什么要用MQ。
			缺点：导致系统更加复杂，系统的可用性降低。
		
		3、kafka、activeMq、rabbitMq、RocketMQ的区别以及适合场景？
			
		
		4、MQ积压处理。
		
		5、你们公司为什么要用对应的MQ。
			第一是基于公司框架，技术成熟。公司吞吐量不是很大 
			
		
		
	10)、spring boot和Spring cloud的缺点。
		
		
		
	11)、Tcp三次握手的过程和四次挥手。
		1)、三次握手的过程
			1、第一次：client -> server【SYN = 1，seq（客户端自己的） = x】
				* 【SYN = 1,seq = x】客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。
				* SYN = 1 就是表达客户端要与Server端建立连接。
				* 这个一步的作用：表示客户端请求与服务端建立连接。
				
			2、第二次：server -> client【ACK = 1，ack = x + 1, SYN = 1，seq = y】
				* 服务器收到客户端SYN包，必须确认客户的SYN（返回一个ack包：ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN + ACK包，此时服务器进入SYN_RECV状态；
				* 这个一步的作用：对客户端请求建立连接的确认【使用ACK确认】；我服务端也想和你建立连接【使用SYN】。
				
			3、第三次：client -> server【ACK = 1， seq = y + 1】
				* 客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。
				* 这个一步的作用：确认服务端要与客户端建立请求。
				
			
			Client   			Server
			Close				LISTEN
			SYN-SEND			LISTEN
			SYN-SEND			SYN-RCVD
			ESTABLISH			SYN-RCVD
			ESTABLISH			ESTABLISH
					 传输数据
					 <=======>
				
		2)、为什么非要是三次握手
			1、多了浪费、少了不行。
			
		3)、四次挥手
			1、第一次：client  -> Server【FIN = 1，seq = u】
				* 客户端进程发出【连接释放】报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，
				  客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。
				* FIN = 1，发起断开连接的请求。
				* 这个一步的作用：表示客户端请求断开连接。
				
			2、第二次：server -> client【ACK = 1，seq = v, ack = u + 1】
				* 服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，
				  客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。
				* 这个一步的作用：表示服务端接收到客户端发起的断开连接的请求。
				
				
			3、第三次：server -> client【FIN = 1，seq = w，ACK = 1， ack = u + 1】
				* 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）
				  状态，等待客户端的确认。
				
			4、第四次：client -> server【ACK = 1，seq = u + 1 ，ack = w + 1】
				* 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段
				  寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。
		
		https://www.bilibili.com/video/BV1HQ4y1M7oe
		https://www.cnblogs.com/bj-mr-li/p/11106390.html
		
	12)、Java8的新特性
		1、default：只能用于接口。本身的优先级最高、父接口优先级次之、还是无法选择，这个时候就会报错。
		2、lambda表达式：函数式编程、方法推导。Consumer、Function、Predicate、Supplier
		3、Stream：常用方法filter、map、distinct、limit、skip、find..、..Match.
		4、forkjoin：
		5、新的日期：LocalDate（final修饰）
		
		
		
		
		
		
		
		
		