
零、待处理：
	WebDataBinder：这个怎么使用。
	
	1、获取请求参数，并转为方法指定的对象。
	2、获取参数以后进行参数校验（DataBinder）。



三、重要的类：
	ServletInvocableHandlerMethod：

	HandlerMethodArgumentResolver
	
	
四、源码

/**
 * 通过
 * 
 * 
 * 主要步骤：
 * 		1、遍历HandlerMehtod中的所有参数。首先通过参数类型获取对应的HandlerMethodArgumentResolver。然后在HandlerMethodArgumentResolver中解析请求并把请求
 *		   转换成HandlerMehtod中参数类型的实例，这里通过HttpMessageConverter进行读取信息和装换操作，可以通过Content-Type和参数类型获取适合的HttMessageConverter
 *		   
 * 		2、构建一个WebDataBinder，进行必要的参数校验处理。
 * 
 * 调用HandlerMethod的过程
 */
location：RequestMappingHandlerAdapter
protected ModelAndView invokeHandlerMethod(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception {
	
	// 创建ServletWebRequest对象。
	ServletWebRequest webRequest = new ServletWebRequest(request, response);
	
	try {
		/**
		 * 获取WebDataBinderFactory，并构建ModelFactory。
		 * 		
		 */
		WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod);
		ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory);

		/**
		 * 创建ServletInvocableHandlerMethod实例，并为其设置属性，ServletInvocableHandlerMethod是HandlerMethod的子类。
		 */
		ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod);
		invocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers);
		invocableMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers);
		invocableMethod.setDataBinderFactory(binderFactory);
		invocableMethod.setParameterNameDiscoverer(this.parameterNameDiscoverer);

		/**
		 * 创建ModelAndViewContainer实例，并为其设置属性。
		 */
		ModelAndViewContainer mavContainer = new ModelAndViewContainer();
		mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));
		modelFactory.initModel(webRequest, mavContainer, invocableMethod);
		mavContainer.setIgnoreDefaultModelOnRedirect(this.ignoreDefaultModelOnRedirect);

		/**
		 * 构建AsyncWebRequest实例对象，并设置属性。
		 */
		AsyncWebRequest asyncWebRequest = WebAsyncUtils.createAsyncWebRequest(request, response);
		asyncWebRequest.setTimeout(this.asyncRequestTimeout);

		/**
		 * 构建WebAsyncManager实例对象，并设置属性。
		 */
		WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);
		asyncManager.setTaskExecutor(this.taskExecutor);
		asyncManager.setAsyncWebRequest(asyncWebRequest);
		asyncManager.registerCallableInterceptors(this.callableInterceptors);
		asyncManager.registerDeferredResultInterceptors(this.deferredResultInterceptors);

		
		if (asyncManager.hasConcurrentResult()) {
			Object result = asyncManager.getConcurrentResult();
			mavContainer = (ModelAndViewContainer) asyncManager.getConcurrentResultContext()[0];
			asyncManager.clearConcurrentResult();
			if (logger.isDebugEnabled()) {
				logger.debug("Found concurrent result value [" + result + "]");
			}
			
			invocableMethod = invocableMethod.wrapConcurrentResult(result);
		}

		/**
		 * ##################################################################################
		 * # 			会调用具体的Handler内容，即你写的Controller里具体的方法				#
		 * ##################################################################################
		 */
		invocableMethod.invokeAndHandle(webRequest, mavContainer);
		
		
		if (asyncManager.isConcurrentHandlingStarted()) {
			return null;
		}

		/**
		 * 获取ModelAndView
		 */
		return getModelAndView(mavContainer, modelFactory, webRequest);
	} finally {
		webRequest.requestCompleted();
	}
}



/**
 * 具体的处理HandlerMapping操作。
 *
 * 
 *
 * 在构建ServletInvocableHandlerMethod的时候会把HandlerMethod传入其中
 */
location：ServletInvocableHandlerMethod
public void invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception {

	/**
	 * 执行具体的HandlerMapping。
	 */
	Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);
	
	// 设置响应状态。
	setResponseStatus(webRequest);

	if (returnValue == null) {
		if (isRequestNotModified(webRequest) || getResponseStatus() != null || mavContainer.isRequestHandled()) {
			mavContainer.setRequestHandled(true);
			return;
		}
	} else if (StringUtils.hasText(getResponseStatusReason())) {
		mavContainer.setRequestHandled(true);
		return;
	}

	mavContainer.setRequestHandled(false);
	
	try {
		this.returnValueHandlers.handleReturnValue(returnValue, getReturnValueType(returnValue), mavContainer, webRequest);
	} catch (Exception ex) {
		if (logger.isTraceEnabled()) {
			logger.trace(getReturnValueHandlingErrorMessage("Error handling return value", returnValue), ex);
		}
		throw ex;
	}
}

/**
 * HandlerMethod
 *			InvocableHandlerMethod
 *						ServletInvocableHandlerMethod
 *
 * 1、参数处理。
 *
 * 
 */
location：InvocableHandlerMethod
public Object invokeForRequest(NativeWebRequest request, ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception {

	/**
	 * ##########################################
	 * #  				参数处理				#
	 * ##########################################
	 */
	Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);
	
	if (logger.isTraceEnabled()) {
		logger.trace("Invoking '" + ClassUtils.getQualifiedMethodName(getMethod(), getBeanType()) + "' with arguments " + Arrays.toString(args));
	}
	
	// 调用具体Controller的具体方法。
	Object returnValue = doInvoke(args);
	
	if (logger.isTraceEnabled()) {
		logger.trace("Method [" + ClassUtils.getQualifiedMethodName(getMethod(), getBeanType()) + "] returned [" + returnValue + "]");
	}
	return returnValue;
}



/**
 *
 *
 */
location：InvocableHandlerMethod
private Object[] getMethodArgumentValues(NativeWebRequest request, ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception {
	
	/**
	 * 获取方法操作，在构建ServletInvocableHandlerMethod实例时传入的，就是HandlerMapping对应的方法的参数，只是
	 * mvc进行了一层包装而已。
	 */
	MethodParameter[] parameters = getMethodParameters();
	Object[] args = new Object[parameters.length];
	
	/**
	 * 遍历方法参数。
	 */
	for (int i = 0; i < parameters.length; i++) {
		MethodParameter parameter = parameters[i];
		
		/**
		 * ParameterNameDiscoverer parameterNameDiscoverer = new DefaultParameterNameDiscoverer();
		 * 设置MethodParameter的parameterNameDiscoverer，这里默认为DefaultParameterNameDiscoverer。
		 */
		parameter.initParameterNameDiscovery(this.parameterNameDiscoverer);
		
		/**
		 * 尝试去解析一个方法参数从提供的参数值列表中。RequestMappingHandlerAdapter一般情况是为空的。
		 */
		args[i] = resolveProvidedArgument(parameter, providedArgs);
		if (args[i] != null) {
			continue;
		}
		
		/**
		 * 遍历RequestMappingHandlerAdapter中支持的HttpMessageConvercer，找到适合处理该MethodParameter。
		 * HandlerMethodArgumentResolver
		 *			1、MapMethodProcessor
		 *					public boolean supportsParameter(MethodParameter parameter) {
		 *						return Map.class.isAssignableFrom(parameter.getParameterType());
		 *					}
		 *
		 *			2、ModelAttributeMethodProcessor
		 *					public boolean supportsParameter(MethodParameter parameter) {
		 *						return (parameter.hasParameterAnnotation(ModelAttribute.class) || (this.annotationNotRequired && !BeanUtils.isSimpleProperty(parameter.getParameterType())));
		 *					}
		 *					
		 *			3、HandlerMethodArgumentResolverComposite
		 *					public boolean supportsParameter(MethodParameter parameter) {
		 *						return (getArgumentResolver(parameter) != null);
		 *					}
		 *			
		 *
		 */
		if (this.argumentResolvers.supportsParameter(parameter)) {
			try {
				
				/**
				 * 解析参数。
				 *
				 */
				args[i] = this.argumentResolvers.resolveArgument(parameter, mavContainer, request, this.dataBinderFactory);
				continue;
			} catch (Exception ex) {
				if (logger.isDebugEnabled()) {
					logger.debug(getArgumentResolutionErrorMessage("Failed to resolve", i), ex);
				}
				throw ex;
			}
		}
		
		
		if (args[i] == null) {
			throw new IllegalStateException("Could not resolve method parameter at index " + ": " + getArgumentResolutionErrorMessage("No suitable resolver for", i));
		}
	}
	return args;
}

/**
 * 尝试去解析一个方法参数从提供的参数值列表中。
 */
location：InvocableHandlerMethod
private Object resolveProvidedArgument(MethodParameter parameter, Object... providedArgs) {
	if (providedArgs == null) {
		return null;
	}
	for (Object providedArg : providedArgs) {
		if (parameter.getParameterType().isInstance(providedArg)) {
			return providedArg;
		}
	}
	return null;
}


/**
 * 
 */
location：HandlerMethodArgumentResolverComposite
public boolean supportsParameter(MethodParameter parameter) {
	return (getArgumentResolver(parameter) != null);
}

/**
 *
 */
location：HandlerMethodArgumentResolverComposite
private HandlerMethodArgumentResolver getArgumentResolver(MethodParameter parameter) {
	/**
	 * 从缓存中获取。
	 */
	HandlerMethodArgumentResolver result = this.argumentResolverCache.get(parameter);
	
	/**
	 * 遍历所有的HandlerMethodArgumentResolver实例，找到能够支持该MethodParameter，找到以后并放入缓存中。
	 */
	if (result == null) {
		for (HandlerMethodArgumentResolver methodArgumentResolver : this.argumentResolvers) {
			if (logger.isTraceEnabled()) {
				logger.trace("Testing if argument resolver [" + methodArgumentResolver + "] supports [" + parameter.getGenericParameterType() + "]");
			}
			
			if (methodArgumentResolver.supportsParameter(parameter)) {
				result = methodArgumentResolver;
				this.argumentResolverCache.put(parameter, result);
				break;
			}
		}
	}
	
	return result;
}



/**
 *
 */
location：HandlerMethodArgumentResolverComposite
public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception {

	/**
	 * 获取支持的HandlerMethodArgumentResolver
	 */
	HandlerMethodArgumentResolver resolver = getArgumentResolver(parameter);
	
	if (resolver == null) {
		throw new IllegalArgumentException("Unknown parameter type [" + parameter.getParameterType().getName() + "]");
	}
	
	/**
	 * 解析参数。这里以RequestResponseBodyMethodProcessor
	 */
	return resolver.resolveArgument(parameter, mavContainer, webRequest, binderFactory);
}



/**
 *
 */
location：RequestResponseBodyMethodProcessor
public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception {

	parameter = parameter.nestedIfOptional();
	
	/**
	 * 读取请求信息，并转化为给定接收类的对象。
	 */
	Object arg = readWithMessageConverters(webRequest, parameter, parameter.getNestedGenericParameterType());
	
	/**
	 * 获取RequestMapping中的方法参数名称。
	 */
	String name = Conventions.getVariableNameForParameter(parameter);

	/**
	 * 创建WebDataBinder
	 */
	WebDataBinder binder = binderFactory.createBinder(webRequest, arg, name);
	
	
	/**
	 * ##################################################
	 * #			WebDataBinder参数校验				#
	 * ##################################################
	 */
	if (arg != null) {
		validateIfApplicable(binder, parameter);
		if (binder.getBindingResult().hasErrors() && isBindExceptionRequired(binder, parameter)) {
			throw new MethodArgumentNotValidException(parameter, binder.getBindingResult());
		}
	}
	
	/**
	 * 把BindingResult放入ModelAndViewContainer。
	 */
	mavContainer.addAttribute(BindingResult.MODEL_KEY_PREFIX + name, binder.getBindingResult());

	return adaptArgumentIfNecessary(arg, parameter);
}


/**
 * 读取请求信息，并转化为给定接收类的对象。
 */
location：RequestResponseBodyMethodProcessor
protected <T> Object readWithMessageConverters(NativeWebRequest webRequest, MethodParameter parameter, Type paramType) throws IOException, HttpMediaTypeNotSupportedException, HttpMessageNotReadableException {

	HttpServletRequest servletRequest = webRequest.getNativeRequest(HttpServletRequest.class);
	
	/**
	 * 能够解析Request，可以获取协议、远程地址、请求头、uri、body等等。
	 */
	ServletServerHttpRequest inputMessage = new ServletServerHttpRequest(servletRequest);

	/**
	 * 读取请求信息，并转化为给定接收类的对象。
	 */
	Object arg = readWithMessageConverters(inputMessage, parameter, paramType);
	
	if (arg == null) {
		if (checkRequired(parameter)) {
			throw new HttpMessageNotReadableException("Required request body is missing: " + parameter.getMethod().toGenericString());
		}
	}
	
	return arg;
}


/**
 * 获取合适的HttpMessageConverter处理请求数据，这里是MappingJackson2HttpMessageConverter实例。从请求中获取到数据并转化为给定的对象。
 */
location：AbstractMessageConverterMethodArgumentResolver
protected <T> Object readWithMessageConverters(HttpInputMessage inputMessage, MethodParameter parameter, Type targetType) throws IOException, HttpMediaTypeNotSupportedException, HttpMessageNotReadableException {

	MediaType contentType;
	boolean noContentType = false;
	
	/**
	 * 获取请求的Content-Type，如果没有默认使用application/octet-stream。
	 */
	try {
		contentType = inputMessage.getHeaders().getContentType();
	} catch (InvalidMediaTypeException ex) {
		throw new HttpMediaTypeNotSupportedException(ex.getMessage());
	}
	if (contentType == null) {
		noContentType = true;
		contentType = MediaType.APPLICATION_OCTET_STREAM;
	}

	/**
	 * contextClass：RequestMapping对应的类。
	 * targetClass：就是RequestMappin对应的方法的参数类型。
	 */
	Class<?> contextClass = (parameter != null ? parameter.getContainingClass() : null);
	Class<T> targetClass = (targetType instanceof Class ? (Class<T>) targetType : null);
	if (targetClass == null) {
		ResolvableType resolvableType = (parameter != null ? ResolvableType.forMethodParameter(parameter) : ResolvableType.forType(targetType));
		targetClass = (Class<T>) resolvableType.resolve();
	}

	// 获取Http_Method的类型。
	HttpMethod httpMethod = ((HttpRequest) inputMessage).getMethod();
	Object body = NO_VALUE;

	try {
		inputMessage = new EmptyBodyCheckingHttpInputMessage(inputMessage);
		
		/**
		 * ##############################################
		 * #   查找HttpMessageConverter并进行处理 		#
		 * ##############################################
		 */
		for (HttpMessageConverter<?> converter : this.messageConverters) {
			Class<HttpMessageConverter<?>> converterType = (Class<HttpMessageConverter<?>>) converter.getClass();
			
			/**
			 * 是否是GenericHttpMessageConverter
			 */
			if (converter instanceof GenericHttpMessageConverter) {
				GenericHttpMessageConverter<?> genericConverter = (GenericHttpMessageConverter<?>) converter;
				
				/**
				 * 判断HttpMessageConverter是否支持给定接收参数类型和Content-Type。
				 */
				if (genericConverter.canRead(targetType, contextClass, contentType)) {
					if (logger.isDebugEnabled()) {
						logger.debug("Read [" + targetType + "] as \"" + contentType + "\" with [" + converter + "]");
					}
					
					if (inputMessage.getBody() != null) {
						inputMessage = getAdvice().beforeBodyRead(inputMessage, parameter, targetType, converterType);
						body = genericConverter.read(targetType, contextClass, inputMessage);
						body = getAdvice().afterBodyRead(body, inputMessage, parameter, targetType, converterType);
					} else {
						body = getAdvice().handleEmptyBody(null, inputMessage, parameter, targetType, converterType);
					}
					break;
				}
			} else if (targetClass != null) {
				/**
				 * 判断HttpMessageConverter是否支持给定接收参数类型和Content-Type。
				 */
				if (converter.canRead(targetClass, contentType)) {
					if (logger.isDebugEnabled()) {
						logger.debug("Read [" + targetType + "] as \"" + contentType + "\" with [" + converter + "]");
					}
					
					/**
					 * 获取请求
					 */
					if (inputMessage.getBody() != null) {
						/**
						 *  RequestResponseBodyAdviceChain前置处理。
						 */
						inputMessage = getAdvice().beforeBodyRead(inputMessage, parameter, targetType, converterType);
						
						/**
						 * RequestResponseBodyAdviceChain读取数据。把数据转化为对应实体对象。
						 */
						body = ((HttpMessageConverter<T>) converter).read(targetClass, inputMessage);
						
						/**
						 * RequestResponseBodyAdviceChain后置处理。
						 */
						body = getAdvice().afterBodyRead(body, inputMessage, parameter, targetType, converterType);
					} else {
						body = getAdvice().handleEmptyBody(null, inputMessage, parameter, targetType, converterType);
					}
					
					break;
				}
			}
		}
	} catch (IOException ex) {
		throw new HttpMessageNotReadableException("I/O error while reading input message", ex);
	}

	if (body == NO_VALUE) {
		if (httpMethod == null || !SUPPORTED_METHODS.contains(httpMethod) || (noContentType && inputMessage.getBody() == null)) {
			return null;
		}
		
		throw new HttpMediaTypeNotSupportedException(contentType, this.allSupportedMediaTypes);
	}
	
	return body;
}



/**
 * 这里以RequestResponseBodyMethodProcessor为例。
 */
location：AbstractMessageConverterMethodArgumentResolver
protected RequestResponseBodyAdviceChain getAdvice() {
	return this.advice;
}

/**
 *
 */
location：RequestResponseBodyAdviceChain
public HttpInputMessage beforeBodyRead(HttpInputMessage request, MethodParameter parameter, Type targetType, Class<? extends HttpMessageConverter<?>> converterType) throws IOException {
	
	/**
	 * 遍历所有RequestBodyAdvice，如果RequestBodyAdvice支持，调用beforeBodyRead(..)方法。
	 */
	for (RequestBodyAdvice advice : getMatchingAdvice(parameter, RequestBodyAdvice.class)) {
		if (advice.supports(parameter, targetType, converterType)) {
			request = advice.beforeBodyRead(request, parameter, targetType, converterType);
		}
	}
	
	return request;
}

/**
 * 读取信息并转换为对象。
 */
location：AbstractJackson2HttpMessageConverter
public Object read(Type type, Class<?> contextClass, HttpInputMessage inputMessage) throws IOException, HttpMessageNotReadableException {

	/**
	 * 以下两个操作主要是通过FastJson。
	 */
	JavaType javaType = getJavaType(type, contextClass);
	return readJavaType(javaType, inputMessage);
}


/**
 * 通过fastJson把数据转化为实体对象。
 */
location：AbstractJackson2HttpMessageConverter
private Object readJavaType(JavaType javaType, HttpInputMessage inputMessage) {
	try {
		if (inputMessage instanceof MappingJacksonInputMessage) {
			Class<?> deserializationView = ((MappingJacksonInputMessage) inputMessage).getDeserializationView();
			
			if (deserializationView != null) {
				return this.objectMapper.readerWithView(deserializationView).forType(javaType).readValue(inputMessage.getBody());
			}
			
		}
		return this.objectMapper.readValue(inputMessage.getBody(), javaType);
	} catch (JsonProcessingException ex) {
		throw new HttpMessageNotReadableException("JSON parse error: " + ex.getOriginalMessage(), ex);
	} catch (IOException ex) {
		throw new HttpMessageNotReadableException("I/O error while reading input message", ex);
	}
}




#############################
# DataBinder参数校验		#
#############################
public final WebDataBinder createBinder(NativeWebRequest webRequest, Object target, String objectName) throws Exception {

	WebDataBinder dataBinder = createBinderInstance(target, objectName, webRequest);
	if (this.initializer != null) {
		this.initializer.initBinder(dataBinder, webRequest);
	}
	initBinder(dataBinder, webRequest);
	return dataBinder;
}

/**
 *
 */
location：DefaultDataBinderFactory
protected ServletRequestDataBinder createBinderInstance(Object target, String objectName, NativeWebRequest request) {
	return new ExtendedServletRequestDataBinder(target, objectName);
}

/**
 *
 */
location：ConfigurableWebBindingInitializer
public void initBinder(WebDataBinder binder, WebRequest request) {
	binder.setAutoGrowNestedPaths(this.autoGrowNestedPaths);
	if (this.directFieldAccess) {
		binder.initDirectFieldAccess();
	}
	if (this.messageCodesResolver != null) {
		binder.setMessageCodesResolver(this.messageCodesResolver);
	}
	if (this.bindingErrorProcessor != null) {
		binder.setBindingErrorProcessor(this.bindingErrorProcessor);
	}
	if (this.validator != null && binder.getTarget() != null &&
			this.validator.supports(binder.getTarget().getClass())) {
		binder.setValidator(this.validator);
	}
	if (this.conversionService != null) {
		binder.setConversionService(this.conversionService);
	}
	if (this.propertyEditorRegistrars != null) {
		for (PropertyEditorRegistrar propertyEditorRegistrar : this.propertyEditorRegistrars) {
			propertyEditorRegistrar.registerCustomEditors(binder);
		}
	}
}

/**
 *
 */
location：InitBinderDataBinderFactory
public void initBinder(WebDataBinder binder, NativeWebRequest request) throws Exception {
	for (InvocableHandlerMethod binderMethod : this.binderMethods) {
		if (isBinderMethodApplicable(binderMethod, binder)) {
			Object returnValue = binderMethod.invokeForRequest(request, null, binder);
			if (returnValue != null) {
				throw new IllegalStateException("@InitBinder methods should return void: " + binderMethod);
			}
		}
	}
}


/**
 *
 */
location：AbstractMessageConverterMethodArgumentResolver
protected void validateIfApplicable(WebDataBinder binder, MethodParameter parameter) {
	/**
	 * 获取方法参数上的注解。
	 */
	Annotation[] annotations = parameter.getParameterAnnotations();
	
	/**
	 * 遍历注解，获取@Validated注解，这个注解是spring-content包中的。
	 */
	for (Annotation ann : annotations) {
		Validated validatedAnn = AnnotationUtils.getAnnotation(ann, Validated.class);
		if (validatedAnn != null || ann.annotationType().getSimpleName().startsWith("Valid")) {
			Object hints = (validatedAnn != null ? validatedAnn.value() : AnnotationUtils.getValue(ann));
			Object[] validationHints = (hints instanceof Object[] ? (Object[]) hints : new Object[] {hints});
			
			/**
			 * 校验
			 */
			binder.validate(validationHints);
			break;
		}
	}
}










/**
 * 其是ServletInvocableHandlerMethod实例。
 * 在构建ServletInvocableHandlerMethod实例时，会把HandlerMethod实例的信息赋值给ServletInvocableHandlerMethod
 */
location：InvocableHandlerMethod
protected Object doInvoke(Object... args) throws Exception {
	ReflectionUtils.makeAccessible(getBridgedMethod());
	try {
		/**
		 * getBridgedMethod()：handlerMethod.bridgedMethod   ==》 就是@RequestMapping修饰具体要调用的方法。返回的是一个Method实例。
		 * getBean()：handlerMethod.bean   ==》  就是@RequestMapping修饰的方法对应的类的实例对象。返回对应的实例。
		 *
		 * 通过反射调用具体方法。
		 */
		return getBridgedMethod().invoke(getBean(), args);
		
		
	} catch (IllegalArgumentException ex) {
		assertTargetBean(getBridgedMethod(), getBean(), args);
		String text = (ex.getMessage() != null ? ex.getMessage() : "Illegal argument");
		throw new IllegalStateException(getInvocationErrorMessage(text, args), ex);
	} catch (InvocationTargetException ex) { 
		Throwable targetException = ex.getTargetException();
		if (targetException instanceof RuntimeException) {
			throw (RuntimeException) targetException;
		} else if (targetException instanceof Error) {
			throw (Error) targetException;
		} else if (targetException instanceof Exception) {
			throw (Exception) targetException;
		} else {
			String text = getInvocationErrorMessage("Failed to invoke handler method", args);
			throw new IllegalStateException(text, targetException);
		}
	}
}







/**
 *
 */
location：HandlerMethodReturnValueHandlerComposite
public void handleReturnValue(Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception {

	// HandlerMethodReturnValueHandler：策略接口处理 程序方法调用返回的值。
	HandlerMethodReturnValueHandler handler = selectHandler(returnValue, returnType);
	
	if (handler == null) {
		throw new IllegalArgumentException("Unknown return value type: " + returnType.getParameterType().getName());
	}
	
	handler.handleReturnValue(returnValue, returnType, mavContainer, webRequest);
}

/**
 * 获取HandlerMethodReturnValueHandler
 *
 * HandlerMethodReturnValueHandler：有很多子类。
 * 		ViewNameMethodReturnValueHandler（void、String）、ViewMethodReturnValueHandler（View）
 * 		ModelMethodProcessor（Modle）、ModelAndViewMethodReturnValueHandler（ModelAndView）
 *		ModelAttributeMethodProcessor（@ModelAttribute）、ResponseBodyEmitterReturnValueHandler
 * 		StreamingResponseBodyReturnValueHandler（）
 */
location：HandlerMethodReturnValueHandlerComposite
private HandlerMethodReturnValueHandler selectHandler(Object value, MethodParameter returnType) {
	boolean isAsyncValue = isAsyncReturnValue(value, returnType);
	
	// HandlerMethodReturnValueHandler：策略接口处理 程序方法调用返回的值。
	for (HandlerMethodReturnValueHandler handler : this.returnValueHandlers) {
		if (isAsyncValue && !(handler instanceof AsyncHandlerMethodReturnValueHandler)) {
			continue;
		}
		if (handler.supportsReturnType(returnType)) {
			return handler;
		}
	}
	return null;
}

/**
 *
 */
location：HandlerMethodReturnValueHandlerComposite
public boolean isAsyncReturnValue(Object value, MethodParameter returnType) {
	for (HandlerMethodReturnValueHandler handler : this.returnValueHandlers) {
		if (handler instanceof AsyncHandlerMethodReturnValueHandler) {
			if (((AsyncHandlerMethodReturnValueHandler) handler).isAsyncReturnValue(value, returnType)) {
				return true;
			}
		}
	}
	return false;
}

/**
 *
 */
location：ViewNameMethodReturnValueHandler
public void handleReturnValue(Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception {

	if (returnValue instanceof CharSequence) {
		String viewName = returnValue.toString();
		mavContainer.setViewName(viewName);
		if (isRedirectViewName(viewName)) {
			mavContainer.setRedirectModelScenario(true);
		}
	} else if (returnValue != null){
		throw new UnsupportedOperationException("Unexpected return type: " + returnType.getParameterType().getName() + " in method: " + returnType.getMethod());
	}
}

############################################################
附件二：有以AnnotationMethodHandlerAdapter为例的
############################################################


#############################################################################################################################
#############################      05、调用HandlerAdapter的handler方法.获取ModelAndView     #################################
#############################################################################################################################
location：RequestMappingHandlerAdapter
private ModelAndView getModelAndView(ModelAndViewContainer mavContainer, ModelFactory modelFactory, NativeWebRequest webRequest) throws Exception {

	modelFactory.updateModel(webRequest, mavContainer);
	
	if (mavContainer.isRequestHandled()) {
		return null;
	}
	
	ModelMap model = mavContainer.getModel();
	
	// 通过视图名称、modelMap和HTTPStatus构建ModelAndView
	ModelAndView mav = new ModelAndView(mavContainer.getViewName(), model, mavContainer.getStatus());
	
	if (!mavContainer.isViewReference()) {
		mav.setView((View) mavContainer.getView());
	}
	
	if (model instanceof RedirectAttributes) {
		Map<String, ?> flashAttributes = ((RedirectAttributes) model).getFlashAttributes();
		HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class);
		RequestContextUtils.getOutputFlashMap(request).putAll(flashAttributes);
	}
	return mav;
}



####################################################################################################################################
########################################          06、添加默认的名称     	########################################################
####################################################################################################################################
/**
 *
 */
location：DispatcherServlet
private void applyDefaultViewName(HttpServletRequest request, ModelAndView mv) throws Exception {
	if (mv != null && !mv.hasView()) {
		mv.setViewName(getDefaultViewName(request));
	}
}

/**
 * 
 */
location：DispatcherServlet
protected String getDefaultViewName(HttpServletRequest request) throws Exception {
	return this.viewNameTranslator.getViewName(request);
}

/**
 * 
 */
location：DefaultRequestToViewNameTranslator
public String getViewName(HttpServletRequest request) {
	String lookupPath = this.urlPathHelper.getLookupPathForRequest(request);
	return (this.prefix + transformPath(lookupPath) + this.suffix);
}


####################################################################################################################################
########################################          07、HandlerExecutionChain后置处理     	########################################
####################################################################################################################################
/**
 * 获取拦截器，并执行拦截器的postHandle方法。
 */
location：HandlerExecutionChain
void applyPostHandle(HttpServletRequest request, HttpServletResponse response, ModelAndView mv) throws Exception {
	// 获取拦截器，
	HandlerInterceptor[] interceptors = getInterceptors();
	
	if (!ObjectUtils.isEmpty(interceptors)) {
	
		for (int i = interceptors.length - 1; i >= 0; i--) {
			HandlerInterceptor interceptor = interceptors[i];
			
			// 并执行拦截器的postHandle方法。
			interceptor.postHandle(request, response, this.handler, mv);
		}
	}
}



####################################################################################################################################
#################################################          08、结果处理、获取视图解析解  	########################################
####################################################################################################################################
/**
 *
 */
location：DispatcherServlet
private void processDispatchResult(HttpServletRequest request, HttpServletResponse response, HandlerExecutionChain mappedHandler, ModelAndView mv, Exception exception) throws Exception {

	boolean errorView = false;

	// 是否有异常。
	if (exception != null) {
		if (exception instanceof ModelAndViewDefiningException) {
			logger.debug("ModelAndViewDefiningException encountered", exception);
			mv = ((ModelAndViewDefiningException) exception).getModelAndView();
		} else {
			Object handler = (mappedHandler != null ? mappedHandler.getHandler() : null);
			mv = processHandlerException(request, response, handler, exception);
			errorView = (mv != null);
		}
	}

	if (mv != null && !mv.wasCleared()) {
		render(mv, request, response);
		if (errorView) {
			WebUtils.clearErrorRequestAttributes(request);
		}
	} else {
		if (logger.isDebugEnabled()) {
			logger.debug("Null ModelAndView returned to DispatcherServlet with name '" + getServletName() + "': assuming HandlerAdapter completed request handling");
		}
	}

	if (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) {		
		return;
	}

	// 拦截器  --   afterCompletion处理。
	if (mappedHandler != null) {
		mappedHandler.triggerAfterCompletion(request, response, null);
	}
}

/**
 *
 */
location：DispatcherServlet
protected void render(ModelAndView mv, HttpServletRequest request, HttpServletResponse response) throws Exception { 

	// 默认的LocaleResolver为AcceptHeaderLocaleResolver。
	// 通过给定的请求解析当前语言环境。
	Locale locale = this.localeResolver.resolveLocale(request);
	
	response.setLocale(locale);

	View view;
	
	if (mv.isReference()) {
		
		// 【【通过视图解析解获取View】】。
		view = resolveViewName(mv.getViewName(), mv.getModelInternal(), locale, request);
		if (view == null) {
			throw new ServletException("Could not resolve view with name '" + mv.getViewName() + "' in servlet with name '" + getServletName() + "'");
		}
	} else {
		view = mv.getView();
		if (view == null) {
			throw new ServletException("ModelAndView [" + mv + "] neither contains a view name nor a " + "View object in servlet with name '" + getServletName() + "'");
		}
	}

	if (logger.isDebugEnabled()) {
		logger.debug("Rendering view [" + view + "] in DispatcherServlet with name '" + getServletName() + "'");
	}
	
	try {
		if (mv.getStatus() != null) {
			response.setStatus(mv.getStatus().value());
		}
		
		view.render(mv.getModelInternal(), request, response);
		
	} catch (Exception ex) {
		if (logger.isDebugEnabled()) {
			logger.debug("Error rendering view [" + view + "] in DispatcherServlet with name '" + getServletName() + "'", ex);
		}
		throw ex;
	}
}

/**
 * 通过给定的请求解析当前语言环境。
 */
location：AcceptHeaderLocaleResolver
public Locale resolveLocale(HttpServletRequest request) {
	Locale defaultLocale = getDefaultLocale();
	if (defaultLocale != null && request.getHeader("Accept-Language") == null) {
		return defaultLocale;
	}
	
	Locale requestLocale = request.getLocale();
	if (isSupportedLocale(requestLocale)) {
		return requestLocale;
	}
	
	Locale supportedLocale = findSupportedLocale(request);
	if (supportedLocale != null) {
		return supportedLocale;
	}
	
	return (defaultLocale != null ? defaultLocale : requestLocale);
}

/**
 * 是否是引用。
 */
location：ModelAndView
public boolean isReference() {
	return (this.view instanceof String);
}


/**
 * 
 */
location：DispatcherServlet
protected View resolveViewName(String viewName, Map<String, Object> model, Locale locale, HttpServletRequest request) throws Exception {

	// 默认ViewResolver是InternalResourceViewResolver。ViewResolver视图解析器。
	// viewResolvers：可以配置多个。
	for (ViewResolver viewResolver : this.viewResolvers) {
		View view = viewResolver.resolveViewName(viewName, locale);
		if (view != null) {
			return view;
		}
	}
	return null;
}

/**
 * 
 */
location：AbstractCachingViewResolver
public View resolveViewName(String viewName, Locale locale) throws Exception {
	if (!isCache()) {
		return createView(viewName, locale);
	} else {
		Object cacheKey = getCacheKey(viewName, locale);
		View view = this.viewAccessCache.get(cacheKey);
		
		if (view == null) {
		
			synchronized (this.viewCreationCache) {
				view = this.viewCreationCache.get(cacheKey);
				
				if (view == null) {
					view = createView(viewName, locale);
					
					if (view == null && this.cacheUnresolved) {
						view = UNRESOLVED_VIEW;
					}
					
					if (view != null) {
						this.viewAccessCache.put(cacheKey, view);
						this.viewCreationCache.put(cacheKey, view);
						if (logger.isTraceEnabled()) {
							logger.trace("Cached view [" + cacheKey + "]");
						}
					}
				}
			}
		}
		
		return (view != UNRESOLVED_VIEW ? view : null);
	}
}


/**
 * 默认为InternalResourcesViewResolver实例。
 * 创建视图
 */
location：UrlBasedViewResolver
protected View createView(String viewName, Locale locale) throws Exception {

	if (!canHandle(viewName, locale)) {
		return null;
	}
	
	// 判读是否是"redirect:"开头的，进行重定向。
	if (viewName.startsWith(REDIRECT_URL_PREFIX)) {
		String redirectUrl = viewName.substring(REDIRECT_URL_PREFIX.length());
		RedirectView view = new RedirectView(redirectUrl, isRedirectContextRelative(), isRedirectHttp10Compatible());
		view.setHosts(getRedirectHosts());
		return applyLifecycleMethods(viewName, view);
	}

	// 判读是否是"forward:"开头的，进行转发。
	if (viewName.startsWith(FORWARD_URL_PREFIX)) {
		String forwardUrl = viewName.substring(FORWARD_URL_PREFIX.length());
		return new InternalResourceView(forwardUrl);
	}
	
	return super.createView(viewName, locale);
}

/**
 * 创建View实例。
 */
location：AbstractCachingViewResolver
protected View createView(String viewName, Locale locale) throws Exception {
	return loadView(viewName, locale);
}

/**
 * 加载视图
 */
location：UrlBasedViewResolver
protected View loadView(String viewName, Locale locale) throws Exception {
	AbstractUrlBasedView view = buildView(viewName);
	View result = applyLifecycleMethods(viewName, view);
	return (view.checkResource(locale) ? result : null);
}

/**
 * InternalResourceViewResolver extends UrlBasedViewResolver
 */
location：InternalResourceViewResolver
protected AbstractUrlBasedView buildView(String viewName) throws Exception {
	InternalResourceView view = (InternalResourceView) super.buildView(viewName);
	if (this.alwaysInclude != null) {
		view.setAlwaysInclude(this.alwaysInclude);
	}
	view.setPreventDispatchLoop(true);
	return view;
}

/**
 * 加载视图
 */
location：UrlBasedViewResolver
protected AbstractUrlBasedView buildView(String viewName) throws Exception {
	// 创建AbstractUrlBasedView实例。
	AbstractUrlBasedView view = (AbstractUrlBasedView) BeanUtils.instantiateClass(getViewClass());
	
	// 设置url。
	view.setUrl(getPrefix() + viewName + getSuffix());

	String contentType = getContentType();
	if (contentType != null) {
		view.setContentType(contentType);
	}

	view.setRequestContextAttribute(getRequestContextAttribute());
	view.setAttributesMap(getAttributesMap());

	Boolean exposePathVariables = getExposePathVariables();
	if (exposePathVariables != null) {
		view.setExposePathVariables(exposePathVariables);
	}
	Boolean exposeContextBeansAsAttributes = getExposeContextBeansAsAttributes();
	if (exposeContextBeansAsAttributes != null) {
		view.setExposeContextBeansAsAttributes(exposeContextBeansAsAttributes);
	}
	String[] exposedContextBeanNames = getExposedContextBeanNames();
	if (exposedContextBeanNames != null) {
		view.setExposedContextBeanNames(exposedContextBeanNames);
	}

	return view;
}

/**
 * 发送响应。
 */
location：AbstractView
public void render(Map<String, ?> model, HttpServletRequest request, HttpServletResponse response) throws Exception {
	if (logger.isTraceEnabled()) {
		logger.trace("Rendering view with name '" + this.beanName + "' with model " + model + " and static attributes " + this.staticAttributes);
	}

	Map<String, Object> mergedModel = createMergedOutputModel(model, request, response);
	
	prepareResponse(request, response);
	
	renderMergedOutputModel(mergedModel, getRequestToExpose(request), response);
}

/**
 *
 */
location：AbstractView
protected Map<String, Object> createMergedOutputModel(Map<String, ?> model, HttpServletRequest request, HttpServletResponse response) {

	Map<String, Object> pathVars = (this.exposePathVariables ? (Map<String, Object>) request.getAttribute(View.PATH_VARIABLES) : null);
 
	int size = this.staticAttributes.size();
	size += (model != null ? model.size() : 0);
	size += (pathVars != null ? pathVars.size() : 0);

	Map<String, Object> mergedModel = new LinkedHashMap<String, Object>(size);
	mergedModel.putAll(this.staticAttributes);
	if (pathVars != null) {
		mergedModel.putAll(pathVars);
	}
	if (model != null) {
		mergedModel.putAll(model);
	}

	if (this.requestContextAttribute != null) {
		mergedModel.put(this.requestContextAttribute, createRequestContext(request, response, mergedModel));
	}

	return mergedModel;
}

/**
 *
 */
location：AbstractView
protected void prepareResponse(HttpServletRequest request, HttpServletResponse response) {
	if (generatesDownloadContent()) {
		response.setHeader("Pragma", "private");
		response.setHeader("Cache-Control", "private, must-revalidate");
	}
}

/**
 * 其是JstlView实例。
 */
location：InternalResourceView
protected void renderMergedOutputModel(Map<String, Object> model, HttpServletRequest request, HttpServletResponse response) throws Exception {

	exposeModelAsRequestAttributes(model, request);

	exposeHelpers(request);

	String dispatcherPath = prepareForRendering(request, response);

	RequestDispatcher rd = getRequestDispatcher(request, dispatcherPath);
	
	if (rd == null) {
		throw new ServletException("Could not get RequestDispatcher for [" + getUrl() + "]: Check that the corresponding file exists within your web application archive!");
	}

	if (useInclude(request, response)) {
		response.setContentType(getContentType());
		if (logger.isDebugEnabled()) {
			logger.debug("Including resource [" + getUrl() + "] in InternalResourceView '" + getBeanName() + "'");
		}
		rd.include(request, response);
	} else {
		if (logger.isDebugEnabled()) {
			logger.debug("Forwarding to resource [" + getUrl() + "] in InternalResourceView '" + getBeanName() + "'");
		}
		
		// 返回。
		rd.forward(request, response);
	}
}




















#############################################################################################################################
#######   附件一      ##########################      02、获取对应的HandlerExecutionChain       #############################
#############################################################################################################################
/**
 * 01、AbstractUrlHandlerMapping
 * 	   获取处理器执行链
 */
location：AbstractUrlHandlerMapping
protected Object getHandlerInternal(HttpServletRequest request) throws Exception {
	// 获取请求的url
	String lookupPath = getUrlPathHelper().getLookupPathForRequest(request);
	
	// 获取处理器执行链
	Object handler = lookupHandler(lookupPath, request);
	
	if (handler == null) {
		Object rawHandler = null;
		
		if ("/".equals(lookupPath)) {
			rawHandler = getRootHandler();
		}
		
		if (rawHandler == null) {
			rawHandler = getDefaultHandler();
		}
		
		if (rawHandler != null) {
		
			if (rawHandler instanceof String) {
				String handlerName = (String) rawHandler;
				rawHandler = getApplicationContext().getBean(handlerName);
			}
			validateHandler(rawHandler, request);
			handler = buildPathExposingHandler(rawHandler, lookupPath, lookupPath, null);
		}
	}
	
	if (handler != null && logger.isDebugEnabled()) {
		logger.debug("Mapping [" + lookupPath + "] to " + handler);
	} else if (handler == null && logger.isTraceEnabled()) {
		logger.trace("No handler mapping found for [" + lookupPath + "]");
	}
	return handler;
}

/**
 * 获取对应请求路径。
 */
location：UrlPathHelper
public String getLookupPathForRequest(HttpServletRequest request) {
	// alwaysUseFullPath初始化为false。
	if (this.alwaysUseFullPath) {
		return getPathWithinApplication(request);
	}
	
	String rest = getPathWithinServletMapping(request);
	if (!"".equals(rest)) {
		return rest;
	} else {
		return getPathWithinApplication(request);
	}
}

/**
 * 
 */
location：UrlPathHelper
public String getPathWithinApplication(HttpServletRequest request) {
	// 获取请求的ContextPath。
	String contextPath = getContextPath(request);
	
	// 获取请求的RequestURI。
	String requestUri = getRequestUri(request);
	
	// 返回requestURI出去ContextPath部分。
	String path = getRemainingPath(requestUri, contextPath, true);
	
	if (path != null) {
		return (StringUtils.hasText(path) ? path : "/");
	} else {
		return requestUri;
	}
}

/**
 * 获取ContextPath。
 */
location：UrlPathHelper
public String getContextPath(HttpServletRequest request) {
	// INCLUDE_CONTEXT_PATH_ATTRIBUTE = "javax.servlet.include.context_path"
	String contextPath = (String) request.getAttribute(WebUtils.INCLUDE_CONTEXT_PATH_ATTRIBUTE);
	
	if (contextPath == null) {
		contextPath = request.getContextPath();
	}
	
	if ("/".equals(contextPath)) {
		contextPath = "";
	}
	
	// 解码。
	return decodeRequestString(request, contextPath);
}

/**
 * 获取RequestURI。
 */
public String getRequestUri(HttpServletRequest request) {
	String uri = (String) request.getAttribute(WebUtils.INCLUDE_REQUEST_URI_ATTRIBUTE);
	if (uri == null) {
		uri = request.getRequestURI();
	}
	return decodeAndCleanUriString(request, uri);
}

/**
 * 
 */
location：AbstractUrlHandlerMapping
protected Object lookupHandler(String urlPath, HttpServletRequest request) throws Exception {
	
	// 通过给定的urlpath获取到Handler。也就是用Controller修饰的类。
	Object handler = this.handlerMap.get(urlPath);
	
	if (handler != null) {
		if (handler instanceof String) {
			String handlerName = (String) handler;
			
			// 获取对应的Bean。
			handler = getApplicationContext().getBean(handlerName);
		}
		
		
		validateHandler(handler, request);
		return buildPathExposingHandler(handler, urlPath, urlPath, null);
	}

	List<String> matchingPatterns = new ArrayList<String>();
	for (String registeredPattern : this.handlerMap.keySet()) {
		if (getPathMatcher().match(registeredPattern, urlPath)) {
			matchingPatterns.add(registeredPattern);
		} else if (useTrailingSlashMatch()) {
			if (!registeredPattern.endsWith("/") && getPathMatcher().match(registeredPattern + "/", urlPath)) {
				matchingPatterns.add(registeredPattern +"/");
			}
		}
	}

	String bestMatch = null;
	Comparator<String> patternComparator = getPathMatcher().getPatternComparator(urlPath);
	
	if (!matchingPatterns.isEmpty()) {
		Collections.sort(matchingPatterns, patternComparator);
		if (logger.isDebugEnabled()) {
			logger.debug("Matching patterns for request [" + urlPath + "] are " + matchingPatterns);
		}
		bestMatch = matchingPatterns.get(0);
	}
	
	if (bestMatch != null) {
		handler = this.handlerMap.get(bestMatch);
		if (handler == null) {
			if (bestMatch.endsWith("/")) {
				handler = this.handlerMap.get(bestMatch.substring(0, bestMatch.length() - 1));
			}
			if (handler == null) {
				throw new IllegalStateException("Could not find handler for best pattern match [" + bestMatch + "]");
			}
		}
		
		if (handler instanceof String) {
			String handlerName = (String) handler;
			handler = getApplicationContext().getBean(handlerName);
		}
		validateHandler(handler, request);
		String pathWithinMapping = getPathMatcher().extractPathWithinPattern(bestMatch, urlPath);

		Map<String, String> uriTemplateVariables = new LinkedHashMap<String, String>();
		
		for (String matchingPattern : matchingPatterns) {
			if (patternComparator.compare(bestMatch, matchingPattern) == 0) {
				Map<String, String> vars = getPathMatcher().extractUriTemplateVariables(matchingPattern, urlPath);
				Map<String, String> decodedVars = getUrlPathHelper().decodePathVariables(request, vars);
				uriTemplateVariables.putAll(decodedVars);
			}
		}
		
		if (logger.isDebugEnabled()) {
			logger.debug("URI Template variables for request [" + urlPath + "] are " + uriTemplateVariables);
		}
		return buildPathExposingHandler(handler, bestMatch, pathWithinMapping, uriTemplateVariables);
	}

	return null;
}

/**
 * 构建一个HandlerExecutionChain，并添加拦截器。
 */
location：AbstractUrlHandlerMapping
protected Object buildPathExposingHandler(Object rawHandler, String bestMatchingPattern, String pathWithinMapping, Map<String, String> uriTemplateVariables) {
	// 实例化一个处理执行链。责任链模式？？？？
	HandlerExecutionChain chain = new HandlerExecutionChain(rawHandler);
	// 添加拦截器。
	chain.addInterceptor(new PathExposingHandlerInterceptor(bestMatchingPattern, pathWithinMapping));
	if (!CollectionUtils.isEmpty(uriTemplateVariables)) {
		chain.addInterceptor(new UriTemplateVariablesHandlerInterceptor(uriTemplateVariables));
	}
	return chain;
}




#############################################################################################################################
#######   附件二      ##########################         05、调用HandlerAdapter的handler方法     ############################
#############################################################################################################################
/**
 * 以AnnotationMethodHandlerAdapter【HandlerAdapter】为例，Handler的执行过程。
 * 05、真正执行handler过程
 */
location：AnnotationMethodHandlerAdapter
public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
	
	// 获取HandlerAdapter的Class对象。
	Class<?> clazz = ClassUtils.getUserClass(handler);
	
	// false。session注解类缓存
	Boolean annotatedWithSessionAttributes = this.sessionAnnotatedClassesCache.get(clazz);
	if (annotatedWithSessionAttributes == null) {
		annotatedWithSessionAttributes = (AnnotationUtils.findAnnotation(clazz, SessionAttributes.class) != null);
		this.sessionAnnotatedClassesCache.put(clazz, annotatedWithSessionAttributes);
	}

	// 检查请求，准备相应。
	if (annotatedWithSessionAttributes) {
		checkAndPrepare(request, response, this.cacheSecondsForSessionAttributeHandlers, true);
	} else {
		checkAndPrepare(request, response, true);
	}

	// 判读是否需要同步执行invokeHandlerMethod(...)
	if (this.synchronizeOnSession) {
		HttpSession session = request.getSession(false);
		
		if (session != null) {
			Object mutex = WebUtils.getSessionMutex(session);
			synchronized (mutex) {
				return invokeHandlerMethod(request, response, handler);
			}
		}
	}

	return invokeHandlerMethod(request, response, handler);
}

/**
 * 
 */
location：WebContentGenerator
protected final void checkAndPrepare(HttpServletRequest request, HttpServletResponse response, boolean lastModified) throws ServletException {
	checkRequest(request);
	prepareResponse(response);
}

/**
 * 检查请求。检查请求方法，和session。
 */
location：WebContentGenerator
protected final void checkRequest(HttpServletRequest request) throws ServletException {

	String method = request.getMethod();
	if (this.supportedMethods != null && !this.supportedMethods.contains(method)) {
		throw new HttpRequestMethodNotSupportedException(method, this.supportedMethods);
	}

	if (this.requireSession && request.getSession(false) == null) {
		throw new HttpSessionRequiredException("Pre-existing session required but none found");
	}
}

/**
 * 准备相应。设置一些相应头参数。
 */
location：WebContentGenerator
protected final void prepareResponse(HttpServletResponse response) {
	if (this.cacheControl != null) {
		applyCacheControl(response, this.cacheControl);
	} else {
		applyCacheSeconds(response, this.cacheSeconds);
	}
	
	if (servlet3Present && this.varyByRequestHeaders != null) {
		for (String value : getVaryRequestHeadersToAdd(response)) {
			response.addHeader("Vary", value);
		}
	}
}

protected final void applyCacheControl(HttpServletResponse response, CacheControl cacheControl) {
	String ccValue = cacheControl.getHeaderValue();
	if (ccValue != null) {
		response.setHeader(HEADER_CACHE_CONTROL, ccValue);

		if (response.containsHeader(HEADER_PRAGMA)) {
			response.setHeader(HEADER_PRAGMA, "");
		}
		if (response.containsHeader(HEADER_EXPIRES)) {
			response.setHeader(HEADER_EXPIRES, "");
		}
	}
}

/**
 * 调用HandlerMethod。
 */
location：AnnotationMethodHandlerAdapter
protected ModelAndView invokeHandlerMethod(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
	
	// 01、获取ServletHandlerMethodResolver实例。
	ServletHandlerMethodResolver methodResolver = getMethodResolver(handler);
	
	// 02、获取对应的要执行的方法。
	Method handlerMethod = methodResolver.resolveHandlerMethod(request);
	
	// 创建一个ServletHandlerMethodInvoker。
	ServletHandlerMethodInvoker methodInvoker = new ServletHandlerMethodInvoker(methodResolver);
	
	// 组织一个ServletWebRequest实例。
	ServletWebRequest webRequest = new ServletWebRequest(request, response);
	
	ExtendedModelMap implicitModel = new BindingAwareModelMap();

	// 调用对应的方法。
	Object result = methodInvoker.invokeHandlerMethod(handlerMethod, handler, webRequest, implicitModel);
	
	// 获取ModelAndView。
	ModelAndView mav = methodInvoker.getModelAndView(handlerMethod, handler.getClass(), result, implicitModel, webRequest);
	
	methodInvoker.updateModelAttributes(handler, (mav != null ? mav.getModel() : null), implicitModel, webRequest);
	
	return mav;
}

/**
 * 获取ServletHandlerMethodResolver。
 * ServletHandlerMethodResolver extends HandlerMethodResolver：用于处理程序类型中 解析Web方法注释 的支持类。能够处理@RequestMapping、
 *		@InitBinder、@ModelAttribute、@SessionAttributes
 */
location：AnnotationMethodHandlerAdapter
private ServletHandlerMethodResolver getMethodResolver(Object handler) {

	// 获取Handler的Class对象。handler是@Controller修饰的类。
	Class<?> handlerClass = ClassUtils.getUserClass(handler);
	
	// 从缓存中获取对应的ServletHandlerMethodResolver实例对象。
	ServletHandlerMethodResolver resolver = this.methodResolverCache.get(handlerClass);
	
	if (resolver == null) {
		synchronized (this.methodResolverCache) {
			resolver = this.methodResolverCache.get(handlerClass);
			
			// 如果缓存中没有，new一个ServletHandlerMethodResolver，并放入缓存。
			if (resolver == null) {
				resolver = new ServletHandlerMethodResolver(handlerClass);
				this.methodResolverCache.put(handlerClass, resolver);
			}
		}
	}
	
	return resolver;
}

/**
 * 
 */
location：ServletHandlerMethodResolver
public Method resolveHandlerMethod(HttpServletRequest request) throws ServletException {
	
	// 获取请求RUI
	String lookupPath = urlPathHelper.getLookupPathForRequest(request);
	Comparator<String> pathComparator = pathMatcher.getPatternComparator(lookupPath);
	
	Map<RequestSpecificMappingInfo, Method> targetHandlerMethods = new LinkedHashMap<RequestSpecificMappingInfo, Method>();
	Set<String> allowedMethods = new LinkedHashSet<String>(7);
	String resolvedMethodName = null;
	
	// getHandlerMethods()  ----> Set<Method> handlerMethods = new LinkedHashSet<Method>();
	for (Method handlerMethod : getHandlerMethods()) {
		RequestSpecificMappingInfo mappingInfo = new RequestSpecificMappingInfo(this.mappings.get(handlerMethod));
		boolean match = false;
		if (mappingInfo.hasPatterns()) {
			for (String pattern : mappingInfo.getPatterns()) {
				if (!hasTypeLevelMapping() && !pattern.startsWith("/")) {
					pattern = "/" + pattern;
				}
				String combinedPattern = getCombinedPattern(pattern, lookupPath, request);
				if (combinedPattern != null) {
					if (mappingInfo.matches(request)) {
						match = true;
						mappingInfo.addMatchedPattern(combinedPattern);
					}
					else {
						if (!mappingInfo.matchesRequestMethod(request)) {
							allowedMethods.addAll(mappingInfo.methodNames());
						}
						break;
					}
				}
			}
			mappingInfo.sortMatchedPatterns(pathComparator);
		} else if (useTypeLevelMapping(request)) {
			String[] typeLevelPatterns = getTypeLevelMapping().value();
			for (String typeLevelPattern : typeLevelPatterns) {
				if (!typeLevelPattern.startsWith("/")) {
					typeLevelPattern = "/" + typeLevelPattern;
				}
				boolean useSuffixPattern = useSuffixPattern(request);
				if (getMatchingPattern(typeLevelPattern, lookupPath, useSuffixPattern) != null) {
					if (mappingInfo.matches(request)) {
						match = true;
						mappingInfo.addMatchedPattern(typeLevelPattern);
					}
					else {
						if (!mappingInfo.matchesRequestMethod(request)) {
							allowedMethods.addAll(mappingInfo.methodNames());
						}
						break;
					}
				}
			}
			mappingInfo.sortMatchedPatterns(pathComparator);
		} else {
			match = mappingInfo.matches(request);
			if (match && mappingInfo.getMethodCount() == 0 && mappingInfo.getParamCount() == 0 &&
					resolvedMethodName != null && !resolvedMethodName.equals(handlerMethod.getName())) {
				match = false;
			}
			else {
				if (!mappingInfo.matchesRequestMethod(request)) {
					allowedMethods.addAll(mappingInfo.methodNames());
				}
			}
		}
		
		if (match) {
			Method oldMappedMethod = targetHandlerMethods.put(mappingInfo, handlerMethod);
			if (oldMappedMethod != null && oldMappedMethod != handlerMethod) {
				if (methodNameResolver != null && !mappingInfo.hasPatterns()) {
					if (!oldMappedMethod.getName().equals(handlerMethod.getName())) {
						if (resolvedMethodName == null) {
							resolvedMethodName = methodNameResolver.getHandlerMethodName(request);
						}
						if (!resolvedMethodName.equals(oldMappedMethod.getName())) {
							oldMappedMethod = null;
						}
						if (!resolvedMethodName.equals(handlerMethod.getName())) {
							if (oldMappedMethod != null) {
								targetHandlerMethods.put(mappingInfo, oldMappedMethod);
								oldMappedMethod = null;
							}
							else {
								targetHandlerMethods.remove(mappingInfo);
							}
						}
					}
				}
				if (oldMappedMethod != null) {
					throw new IllegalStateException("Ambiguous handler methods mapped for HTTP path '" + lookupPath + "': {" + oldMappedMethod + ", " + handlerMethod +
							"}. If you intend to handle the same path in multiple methods, then factor " + "them out into a dedicated handler class with that path mapped at the type level!");
				}
			}
		}
	}
	if (!targetHandlerMethods.isEmpty()) {
		List<RequestSpecificMappingInfo> matches = new ArrayList<RequestSpecificMappingInfo>(targetHandlerMethods.keySet());
		RequestSpecificMappingInfoComparator requestMappingInfoComparator = new RequestSpecificMappingInfoComparator(pathComparator, request);
		Collections.sort(matches, requestMappingInfoComparator);
		RequestSpecificMappingInfo bestMappingMatch = matches.get(0);
		String bestMatchedPath = bestMappingMatch.bestMatchedPattern();
		
		if (bestMatchedPath != null) {
			extractHandlerMethodUriTemplates(bestMatchedPath, lookupPath, request);
		}
		return targetHandlerMethods.get(bestMappingMatch);
	} else {
		if (!allowedMethods.isEmpty()) {
			throw new HttpRequestMethodNotSupportedException(request.getMethod(), StringUtils.toStringArray(allowedMethods));
		}
		throw new org.springframework.web.servlet.mvc.multiaction.NoSuchRequestHandlingMethodException( lookupPath, request.getMethod(), request.getParameterMap());
	}
}


/**
 * 执行对应的方法。
 */ 
location：HandlerMethodInvoker
public final Object invokeHandlerMethod(Method handlerMethod, Object handler, NativeWebRequest webRequest, ExtendedModelMap implicitModel) throws Exception {

	Method handlerMethodToInvoke = BridgeMethodResolver.findBridgedMethod(handlerMethod);
	
	try {
		boolean debug = logger.isDebugEnabled();
		for (String attrName : this.methodResolver.getActualSessionAttributeNames()) {
			Object attrValue = this.sessionAttributeStore.retrieveAttribute(webRequest, attrName);
			if (attrValue != null) {
				implicitModel.addAttribute(attrName, attrValue);
			}
		}
		
		for (Method attributeMethod : this.methodResolver.getModelAttributeMethods()) {
			Method attributeMethodToInvoke = BridgeMethodResolver.findBridgedMethod(attributeMethod);
			
			Object[] args = resolveHandlerArguments(attributeMethodToInvoke, handler, webRequest, implicitModel);
			
			if (debug) {
				logger.debug("Invoking model attribute method: " + attributeMethodToInvoke);
			}
			String attrName = AnnotationUtils.findAnnotation(attributeMethod, ModelAttribute.class).value();
			
			if (!"".equals(attrName) && implicitModel.containsAttribute(attrName)) {
				continue;
			}
			ReflectionUtils.makeAccessible(attributeMethodToInvoke);
			Object attrValue = attributeMethodToInvoke.invoke(handler, args);
			
			if ("".equals(attrName)) {
				Class<?> resolvedType = GenericTypeResolver.resolveReturnType(attributeMethodToInvoke, handler.getClass());
				attrName = Conventions.getVariableNameForReturnType(attributeMethodToInvoke, resolvedType, attrValue);
			}
			
			if (!implicitModel.containsAttribute(attrName)) {
				implicitModel.addAttribute(attrName, attrValue);
			}
		}
		
		// 获取参数。
		Object[] args = resolveHandlerArguments(handlerMethodToInvoke, handler, webRequest, implicitModel);
		
		if (debug) {
			logger.debug("Invoking request handler method: " + handlerMethodToInvoke);
		}
		
		ReflectionUtils.makeAccessible(handlerMethodToInvoke);
		
		// ########## 真正调用Mapping #########
		return handlerMethodToInvoke.invoke(handler, args);
	}
	catch (IllegalStateException ex) {
		throw new HandlerMethodInvocationException(handlerMethodToInvoke, ex);
	} catch (InvocationTargetException ex) {
		ReflectionUtils.rethrowException(ex.getTargetException());
		return null;
	}
}

/**
 * 获取对应的ModelAndView。
 */
location：AnnotationMethodHandlerAdapter.ServletHandlerMethodInvoker
public ModelAndView getModelAndView(Method handlerMethod, Class<?> handlerType, Object returnValue, ExtendedModelMap implicitModel, ServletWebRequest webRequest) throws Exception {

	// 获取相应结果。
	ResponseStatus responseStatus = AnnotatedElementUtils.findMergedAnnotation(handlerMethod, ResponseStatus.class);
	
	if (responseStatus != null) {
		HttpStatus statusCode = responseStatus.code();
		String reason = responseStatus.reason();
		
		if (!StringUtils.hasText(reason)) {
			webRequest.getResponse().setStatus(statusCode.value());
		} else {
			webRequest.getResponse().sendError(statusCode.value(), reason);
		}

		webRequest.getRequest().setAttribute(View.RESPONSE_STATUS_ATTRIBUTE, statusCode);

		this.responseArgumentUsed = true;
	}

	if (customModelAndViewResolvers != null) {
		for (ModelAndViewResolver mavResolver : customModelAndViewResolvers) {
			ModelAndView mav = mavResolver.resolveModelAndView(handlerMethod, handlerType, returnValue, implicitModel, webRequest);
			if (mav != ModelAndViewResolver.UNRESOLVED) {
				return mav;
			}
		}
	}

	if (returnValue instanceof HttpEntity) {
		handleHttpEntityResponse((HttpEntity<?>) returnValue, webRequest);
		return null;
	} else if (AnnotationUtils.findAnnotation(handlerMethod, ResponseBody.class) != null) {
		handleResponseBody(returnValue, webRequest);
		return null;
	} else if (returnValue instanceof ModelAndView) {
		ModelAndView mav = (ModelAndView) returnValue;
		mav.getModelMap().mergeAttributes(implicitModel);
		return mav;
	} else if (returnValue instanceof Model) {
		return new ModelAndView().addAllObjects(implicitModel).addAllObjects(((Model) returnValue).asMap());
	} else if (returnValue instanceof View) {
		return new ModelAndView((View) returnValue).addAllObjects(implicitModel);
	} else if (AnnotationUtils.findAnnotation(handlerMethod, ModelAttribute.class) != null) {
		addReturnValueAsModelAttribute(handlerMethod, handlerType, returnValue, implicitModel);
		return new ModelAndView().addAllObjects(implicitModel);
	} else if (returnValue instanceof Map) {
		return new ModelAndView().addAllObjects(implicitModel).addAllObjects((Map<String, ?>) returnValue);
	} else if (returnValue instanceof String) {
		return new ModelAndView((String) returnValue).addAllObjects(implicitModel);
	} else if (returnValue == null) {
		if (this.responseArgumentUsed || webRequest.isNotModified()) {
			return null;
		} else {
			return new ModelAndView().addAllObjects(implicitModel);
		}
	} else if (!BeanUtils.isSimpleProperty(returnValue.getClass())) {
		addReturnValueAsModelAttribute(handlerMethod, handlerType, returnValue, implicitModel);
		return new ModelAndView().addAllObjects(implicitModel);
	} else {
		throw new IllegalArgumentException("Invalid handler method return value: " + returnValue);
	}
}