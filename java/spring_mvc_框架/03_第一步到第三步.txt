1、初始化做了哪些事情？？
	


location：DispatcherServlet
protected void initStrategies(ApplicationContext context) {
	// MultipartResolver用于文件上传的。文件处理。
	initMultipartResolver(context);
	
	// 国际化处理。
	initLocaleResolver(context);
	
	// 个性化主题处理。
	initThemeResolver(context);
	
	// HandlerMapping。包含静态资源的映射，<mvc:resources>
	initHandlerMappings(context);
	
	// 映射器适配器。
	initHandlerAdapters(context);
	
	// 异常处理。
	initHandlerExceptionResolvers(context);
	
	
	initRequestToViewNameTranslator(context);
	
	// 视图处理。
	initViewResolvers(context);
	initFlashMapManager(context);
}

#############################################################  DispatcherServlet.properties  ##################################################################
org.springframework.web.servlet.LocaleResolver=org.springframework.web.servlet.i18n.AcceptHeaderLocaleResolver
org.springframework.web.servlet.ThemeResolver=org.springframework.web.servlet.theme.FixedThemeResolver
org.springframework.web.servlet.HandlerMapping=org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\
	org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping
org.springframework.web.servlet.HandlerAdapter=org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,\
	org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,\
	org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter
org.springframework.web.servlet.HandlerExceptionResolver=org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerExceptionResolver,\
	org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver,\
	org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver
org.springframework.web.servlet.RequestToViewNameTranslator=org.springframework.web.servlet.view.DefaultRequestToViewNameTranslator
org.springframework.web.servlet.ViewResolver=org.springframework.web.servlet.view.InternalResourceViewResolver
org.springframework.web.servlet.FlashMapManager=org.springframework.web.servlet.support.SessionFlashMapManager
############################################################################################################################################################


################################################################################################################################################
#######################################################################    第一步   ############################################################
################################################################################################################################################
初始化第一步：初始化MultipartResolver。用于文件上传的接口。
		Multipart：['mʌlti:pɑ:t]：多部件的；
		Resolver[rɪ'zɒlvə]：解决，决定；


/**
 * MultipartResolver：用于处理文件请求的。
 * 		boolean isMultipart(HttpServletRequest request)：判断是否是Multipart类型的请求。
 *		MultipartHttpServletRequest resolveMultipart(HttpServletRequest request)：解析HTTP请求，并封装成MultipartHttpServletRequest请求。
 * 		cleanupMultipart(MultipartHttpServletRequest request)：
 * 
 * 初始化DispatcherServlet使用的MultipartResolver。如果没有在BeanFactory中没有获取给定名称的bean，则DispatcherServlet中的multipartResolver为null。
 */
location：DispatcherServlet
private void initMultipartResolver(ApplicationContext context) {
	try {
	
		// 从Context获取multipartResolver为名称，并且MultipartResolver类型的bean。
		this.multipartResolver = context.getBean(MULTIPART_RESOLVER_BEAN_NAME, MultipartResolver.class);
		if (logger.isDebugEnabled()) {
			logger.debug("Using MultipartResolver [" + this.multipartResolver + "]");
		}
		
	} catch (NoSuchBeanDefinitionException ex) { 
		// 默认没有multipart resolver.
		this.multipartResolver = null;
		if (logger.isDebugEnabled()) {
			logger.debug("Unable to locate MultipartResolver with name '" + MULTIPART_RESOLVER_BEAN_NAME + "': no multipart request handling provided");
		}
	}
}


################################################################################################################################################
#######################################################################    第二步   ############################################################
################################################################################################################################################
/**
 * 初始化第二步：初始化LocaleResolver。国际化处理。如果没有配置，默认使用
 */
private void initLocaleResolver(ApplicationContext context) {
	try {
		this.localeResolver = context.getBean(LOCALE_RESOLVER_BEAN_NAME, LocaleResolver.class);
		if (logger.isDebugEnabled()) {
			logger.debug("Using LocaleResolver [" + this.localeResolver + "]");
		}
	} catch (NoSuchBeanDefinitionException ex) {
		// 需要使用一个默认的
		this.localeResolver = getDefaultStrategy(context, LocaleResolver.class);
		if (logger.isDebugEnabled()) {
			logger.debug("Unable to locate LocaleResolver with name '" + LOCALE_RESOLVER_BEAN_NAME + "': using default [" + this.localeResolver + "]");
		}
	}
}

/**
 * 获取默认的策略。
 */
location：DispatcherServlet
protected <T> T getDefaultStrategy(ApplicationContext context, Class<T> strategyInterface) {
	List<T> strategies = getDefaultStrategies(context, strategyInterface);
	if (strategies.size() != 1) {
		throw new BeanInitializationException("DispatcherServlet needs exactly 1 strategy for interface [" + strategyInterface.getName() + "]");
	}
	return strategies.get(0);
}

/**
 * 获取默认的策略。线程配置文件中获取对应的配置，然后加载配置，默认使用AcceptHeaderLocaleResolver。
 */
location：DispatcherServlet
protected <T> List<T> getDefaultStrategies(ApplicationContext context, Class<T> strategyInterface) {
	String key = strategyInterface.getName();
	String value = defaultStrategies.getProperty(key);
	
	if (value != null) {
		String[] classNames = StringUtils.commaDelimitedListToStringArray(value);
		List<T> strategies = new ArrayList<T>(classNames.length);
		for (String className : classNames) {
			try {
				Class<?> clazz = ClassUtils.forName(className, DispatcherServlet.class.getClassLoader());
				Object strategy = createDefaultStrategy(context, clazz);
				strategies.add((T) strategy);
			} catch (ClassNotFoundException ex) {
				throw new BeanInitializationException("Could not find DispatcherServlet's default strategy class [" + className + "] for interface [" + key + "]", ex);
			}
			catch (LinkageError err) {
				throw new BeanInitializationException("Error loading DispatcherServlet's default strategy class [" + className + "] for interface [" + key + "]: problem with class file or dependent class", err);
			}
		}
		return strategies;
	} else {
		return new LinkedList<T>();
	}
}

################################################################################################################################################
#######################################################################    第三步   ############################################################
################################################################################################################################################
/**
 * 个性化主题
 * 初始化第三步：初始化ThemeResolver。默认使用FixedThemeResolver
 */ 
private void initThemeResolver(ApplicationContext context) {
	try {
		this.themeResolver = context.getBean(THEME_RESOLVER_BEAN_NAME, ThemeResolver.class);
		if (logger.isDebugEnabled()) {
			logger.debug("Using ThemeResolver [" + this.themeResolver + "]");
		}
	} catch (NoSuchBeanDefinitionException ex) {
		// 需要使用一个默认的
		this.themeResolver = getDefaultStrategy(context, ThemeResolver.class);
		if (logger.isDebugEnabled()) {
			logger.debug("Unable to locate ThemeResolver with name '" + THEME_RESOLVER_BEAN_NAME + "': using default [" + this.themeResolver + "]");
		}
	}
}


################################################################################################################################################
#######################################################################    第四步   ############################################################
################################################################################################################################################
初始化第四步：初始化HandlerMapping
private void initHandlerMappings(ApplicationContext context) {

	// private List<HandlerMapping> handlerMappings;
	this.handlerMappings = null;

	// detectAllHandlerMappings默认为true
	if (this.detectAllHandlerMappings) {
		// 查找所有的HandlerMappings在ApplicationContext，包含祖先context的
		Map<String, HandlerMapping> matchingBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerMapping.class, true, false);
		
		if (!matchingBeans.isEmpty()) {
			this.handlerMappings = new ArrayList<HandlerMapping>(matchingBeans.values());
			// 我们按顺序排列HandlerMappings。
			AnnotationAwareOrderComparator.sort(this.handlerMappings);
		}
	} else {
		try {
			// HANDLER_MAPPING_BEAN_NAME = handlerMapping。
			// 这个Context是Spring的ApplicationContext还是Spring MVC WebApplicationContext。
			HandlerMapping hm = context.getBean(HANDLER_MAPPING_BEAN_NAME, HandlerMapping.class);
			this.handlerMappings = Collections.singletonList(hm);
		} catch (NoSuchBeanDefinitionException ex) {
			// 忽略，最后将添加一个默认的HandlerMapping
		}
	}

	// 如果没有找到其他映射，请确保我们至少有一个HandlerMapping，通过注册默认的HandlerMapping。
	// 默认初始化两个BeanNameUrlHandlerMapping和DefaultAnnotationHandlerMapping两个HandlerMapping
	if (this.handlerMappings == null) {
		this.handlerMappings = getDefaultStrategies(context, HandlerMapping.class);
		if (logger.isDebugEnabled()) {
			logger.debug("No HandlerMappings found in servlet '" + getServletName() + "': using default");
		}
	}
}


// 创建HandlerMapping。
location：DispatcherServlet
protected Object createDefaultStrategy(ApplicationContext context, Class<?> clazz) {
	return context.getAutowireCapableBeanFactory().createBean(clazz);
}


// 获取ApplicationContext。
location：GenericApplicationContext
public AutowireCapableBeanFactory getAutowireCapableBeanFactory() throws IllegalStateException {
	assertBeanFactoryActive();
	return this.beanFactory;
}

location：AbstractAutowireCapableBeanFactory
public <T> T createBean(Class<T> beanClass) throws BeansException {
	// 使用原型BeanDefinition，以避免将bean注册为依赖bean。
	RootBeanDefinition bd = new RootBeanDefinition(beanClass);
	bd.setScope(SCOPE_PROTOTYPE);
	bd.allowCaching = ClassUtils.isCacheSafe(beanClass, getBeanClassLoader());
	return (T) createBean(beanClass.getName(), bd, null);
}

// 创建Bean
location：AbstractAutowireCapableBeanFactory
protected Object createBean(String beanName, RootBeanDefinition mbd, Object[] args) throws BeanCreationException {
	
	if (logger.isDebugEnabled()) {
		logger.debug("Creating instance of bean '" + beanName + "'");
	}
	
	RootBeanDefinition mbdToUse = mbd;

	// 获取RootBeanDefinition对应的Class。
	Class<?> resolvedClass = resolveBeanClass(mbd, beanName);
	if (resolvedClass != null && !mbd.hasBeanClass() && mbd.getBeanClassName() != null) {
		mbdToUse = new RootBeanDefinition(mbd);
		mbdToUse.setBeanClass(resolvedClass);
	}

	// 准备方法覆盖。
	try {
		mbdToUse.prepareMethodOverrides();
	} catch (BeanDefinitionValidationException ex) {
		throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(), beanName, "Validation of method overrides failed", ex);
	}

	try {
		// 这个的作用理解？？？？？？？？？？？？？
		// 给BeanPostProcessors后处理器一个机会来返回代理来替代真正的实例
		Object bean = resolveBeforeInstantiation(beanName, mbdToUse);
		if (bean != null) {
			return bean;
		}
	} catch (Throwable ex) {
		throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName, "BeanPostProcessor before instantiation of bean failed", ex);
	}

	Object beanInstance = doCreateBean(beanName, mbdToUse, args);
	
	if (logger.isDebugEnabled()) {
		logger.debug("Finished creating instance of bean '" + beanName + "'");
	}
	return beanInstance;
}

#####################################
获取RootBeanDefinition对应的Class。
location：AbstractBeanFactory
protected Class<?> resolveBeanClass(final RootBeanDefinition mbd, String beanName, final Class<?>... typesToMatch) throws CannotLoadBeanClassException {
	try {
		// 判断RootBeanDefinition是否有BeanClass，如果有的话，直接返回。
		if (mbd.hasBeanClass()) {
			return mbd.getBeanClass();
		}
		
		if (System.getSecurityManager() != null) {
			return AccessController.doPrivileged(new PrivilegedExceptionAction<Class<?>>() {
				@Override
				public Class<?> run() throws Exception {
					return doResolveBeanClass(mbd, typesToMatch);
				}
			}, getAccessControlContext());
		} else {
			return doResolveBeanClass(mbd, typesToMatch);
		}
	} catch (PrivilegedActionException pae) {
		ClassNotFoundException ex = (ClassNotFoundException) pae.getException();
		throw new CannotLoadBeanClassException(mbd.getResourceDescription(), beanName, mbd.getBeanClassName(), ex);
	} catch (ClassNotFoundException ex) {
		throw new CannotLoadBeanClassException(mbd.getResourceDescription(), beanName, mbd.getBeanClassName(), ex);
	} catch (LinkageError ex) {
		throw new CannotLoadBeanClassException(mbd.getResourceDescription(), beanName, mbd.getBeanClassName(), ex);
	}
}


location：AbstractAutowireCapableBeanFactory
protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args) throws BeanCreationException {

	// 实例化Bean
	BeanWrapper instanceWrapper = null;
	
	// 判断给定RootBeanDefinition是否是单例。
	if (mbd.isSingleton()) {
		instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);
	}
	
	if (instanceWrapper == null) {
		instanceWrapper = createBeanInstance(beanName, mbd, args);
	}
	
	final Object bean = (instanceWrapper != null ? instanceWrapper.getWrappedInstance() : null);
	Class<?> beanType = (instanceWrapper != null ? instanceWrapper.getWrappedClass() : null);
	mbd.resolvedTargetType = beanType;

	// Allow post-processors to modify the merged bean definition.
	synchronized (mbd.postProcessingLock) {
		if (!mbd.postProcessed) {
			try {
				applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);
			}
			catch (Throwable ex) {
				throw new BeanCreationException(mbd.getResourceDescription(), beanName,
						"Post-processing of merged bean definition failed", ex);
			}
			mbd.postProcessed = true;
		}
	}

	// Eagerly cache singletons to be able to resolve circular references
	// even when triggered by lifecycle interfaces like BeanFactoryAware.
	boolean earlySingletonExposure = (mbd.isSingleton() && this.allowCircularReferences && isSingletonCurrentlyInCreation(beanName));
	
	if (earlySingletonExposure) {
		if (logger.isDebugEnabled()) {
			logger.debug("Eagerly caching bean '" + beanName + "' to allow for resolving potential circular references");
		}
		
		addSingletonFactory(beanName, new ObjectFactory<Object>() {
			@Override
			public Object getObject() throws BeansException {
				return getEarlyBeanReference(beanName, mbd, bean);
			}
		});
	}

	// Initialize the bean instance.
	Object exposedObject = bean;
	try {
		populateBean(beanName, mbd, instanceWrapper);
		if (exposedObject != null) {
			#####################################################
			exposedObject = initializeBean(beanName, exposedObject, mbd);
		}
	} catch (Throwable ex) {
		if (ex instanceof BeanCreationException && beanName.equals(((BeanCreationException) ex).getBeanName())) {
			throw (BeanCreationException) ex;
		} else {
			throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Initialization of bean failed", ex);
		}
	}

	if (earlySingletonExposure) {
		Object earlySingletonReference = getSingleton(beanName, false);
		if (earlySingletonReference != null) {
			if (exposedObject == bean) {
				exposedObject = earlySingletonReference;
			}
			else if (!this.allowRawInjectionDespiteWrapping && hasDependentBean(beanName)) {
				String[] dependentBeans = getDependentBeans(beanName);
				Set<String> actualDependentBeans = new LinkedHashSet<String>(dependentBeans.length);
				for (String dependentBean : dependentBeans) {
					if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {
						actualDependentBeans.add(dependentBean);
					}
				}
				if (!actualDependentBeans.isEmpty()) {
					throw new BeanCurrentlyInCreationException(beanName, "Bean with name '" + beanName + "' has been injected into other beans [" + StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +
							"] in its raw version as part of a circular reference, but has eventually been " + "wrapped. This means that said other beans do not use the final version of the " +
							"bean. This is often the result of over-eager type matching - consider using " + "'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example.");
				}
			}
		}
	}

	// Register bean as disposable.
	try {
		registerDisposableBeanIfNecessary(beanName, bean, mbd);
	}
	catch (BeanDefinitionValidationException ex) {
		throw new BeanCreationException(
				mbd.getResourceDescription(), beanName, "Invalid destruction signature", ex);
	}

	return exposedObject;
}


location：AbstractAutowireCapableBeanFactory
protected Object initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) {
	if (System.getSecurityManager() != null) {
		AccessController.doPrivileged(new PrivilegedAction<Object>() {
			@Override
			public Object run() {
				invokeAwareMethods(beanName, bean);
				return null;
			}
		}, getAccessControlContext());
	} else {
		invokeAwareMethods(beanName, bean);
	}

	Object wrappedBean = bean;
	if (mbd == null || !mbd.isSynthetic()) {
		wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);
	}

	try {
		invokeInitMethods(beanName, wrappedBean, mbd);
	}
	catch (Throwable ex) {
		throw new BeanCreationException(
				(mbd != null ? mbd.getResourceDescription() : null),
				beanName, "Invocation of init method failed", ex);
	}

	if (mbd == null || !mbd.isSynthetic()) {
		wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);
	}
	return wrappedBean;
}



location：AbstractAutowireCapableBeanFactory
public Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName) throws BeansException {

	Object result = existingBean;
	for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {
		result = beanProcessor.postProcessBeforeInitialization(result, beanName);
		if (result == null) {
			return result;
		}
	}
	return result;
}


location：ApplicationContextAwareProcessor
public Object postProcessBeforeInitialization(final Object bean, String beanName) throws BeansException {
	AccessControlContext acc = null;

	if (System.getSecurityManager() != null &&
			(bean instanceof EnvironmentAware || bean instanceof EmbeddedValueResolverAware ||
					bean instanceof ResourceLoaderAware || bean instanceof ApplicationEventPublisherAware ||
					bean instanceof MessageSourceAware || bean instanceof ApplicationContextAware)) {
		acc = this.applicationContext.getBeanFactory().getAccessControlContext();
	}

	if (acc != null) {
		AccessController.doPrivileged(new PrivilegedAction<Object>() {
			@Override
			public Object run() {
				invokeAwareInterfaces(bean);
				return null;
			}
		}, acc);
	}
	else {
		invokeAwareInterfaces(bean);
	}

	return bean;
}

location：ApplicationContextAwareProcessor
private void invokeAwareInterfaces(Object bean) {
	if (bean instanceof Aware) {
		if (bean instanceof EnvironmentAware) {
			((EnvironmentAware) bean).setEnvironment(this.applicationContext.getEnvironment());
		}
		if (bean instanceof EmbeddedValueResolverAware) {
			((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(this.embeddedValueResolver);
		}
		if (bean instanceof ResourceLoaderAware) {
			((ResourceLoaderAware) bean).setResourceLoader(this.applicationContext);
		}
		if (bean instanceof ApplicationEventPublisherAware) {
			((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(this.applicationContext);
		}
		if (bean instanceof MessageSourceAware) {
			((MessageSourceAware) bean).setMessageSource(this.applicationContext);
		}
		if (bean instanceof ApplicationContextAware) {
			((ApplicationContextAware) bean).setApplicationContext(this.applicationContext);
		}
	}
}



location：ApplicationObjectSupport
public final void setApplicationContext(ApplicationContext context) throws BeansException {
	if (context == null && !isContextRequired()) {
		// Reset internal context state.
		this.applicationContext = null;
		this.messageSourceAccessor = null;
	}
	else if (this.applicationContext == null) {
		// Initialize with passed-in context.
		if (!requiredContextClass().isInstance(context)) {
			throw new ApplicationContextException(
					"Invalid application context: needs to be of type [" + requiredContextClass().getName() + "]");
		}
		this.applicationContext = context;
		this.messageSourceAccessor = new MessageSourceAccessor(context);
		initApplicationContext(context);
	}
	else {
		// Ignore reinitialization if same context passed in.
		if (this.applicationContext != context) {
			throw new ApplicationContextException(
					"Cannot reinitialize with different application context: current one is [" +
					this.applicationContext + "], passed-in one is [" + context + "]");
		}
	}
}

location：WebApplicationObjectSupport
protected void initApplicationContext(ApplicationContext context) {
	super.initApplicationContext(context);
	if (this.servletContext == null && context instanceof WebApplicationContext) {
		this.servletContext = ((WebApplicationContext) context).getServletContext();
		if (this.servletContext != null) {
			initServletContext(this.servletContext);
		}
	}
}

location：WebApplicationObjectSupport
protected void initApplicationContext(ApplicationContext context) throws BeansException {
	initApplicationContext();
}

public void initApplicationContext() throws ApplicationContextException {
	super.initApplicationContext();
	detectHandlers();
}


protected void detectHandlers() throws BeansException {
	if (logger.isDebugEnabled()) {
		logger.debug("Looking for URL mappings in application context: " + getApplicationContext());
	}
	String[] beanNames = (this.detectHandlersInAncestorContexts ? BeanFactoryUtils.beanNamesForTypeIncludingAncestors(getApplicationContext(), Object.class) : getApplicationContext().getBeanNamesForType(Object.class));

	// Take any bean name that we can determine URLs for.
	for (String beanName : beanNames) {
		String[] urls = determineUrlsForHandler(beanName);
		if (!ObjectUtils.isEmpty(urls)) {
			// URL paths found: Let's consider it a handler.
			registerHandler(urls, beanName);
		}
		else {
			if (logger.isDebugEnabled()) {
				logger.debug("Rejected bean name '" + beanName + "': no URL paths identified");
			}
		}
	}
}

################################## 注册过程  ##########################################
################################## 注册过程  ##########################################
location：AbstractUrlHandlerMapping
protected void registerHandler(String[] urlPaths, String beanName) throws BeansException, IllegalStateException {
	Assert.notNull(urlPaths, "URL path array must not be null");
	for (String urlPath : urlPaths) {
		registerHandler(urlPath, beanName);
	}
}

location：AbstractUrlHandlerMapping
protected void registerHandler(String urlPath, Object handler) throws BeansException, IllegalStateException {

	Assert.notNull(urlPath, "URL path must not be null");
	Assert.notNull(handler, "Handler object must not be null");
	
	Object resolvedHandler = handler;

	if (!this.lazyInitHandlers && handler instanceof String) {
		String handlerName = (String) handler;
		if (getApplicationContext().isSingleton(handlerName)) {
			resolvedHandler = getApplicationContext().getBean(handlerName);
		}
	}

	Object mappedHandler = this.handlerMap.get(urlPath);
	
	if (mappedHandler != null) {
		if (mappedHandler != resolvedHandler) {
			throw new IllegalStateException("Cannot map " + getHandlerDescription(handler) + " to URL path [" + urlPath + "]: There is already " + getHandlerDescription(mappedHandler) + " mapped.");
		}
	} else {
		if (urlPath.equals("/")) {
			if (logger.isInfoEnabled()) {
				logger.info("Root mapping to " + getHandlerDescription(handler));
			}
			setRootHandler(resolvedHandler);
		} else if (urlPath.equals("/*")) {
			if (logger.isInfoEnabled()) {
				logger.info("Default mapping to " + getHandlerDescription(handler));
			}
			setDefaultHandler(resolvedHandler);
		} else {
			this.handlerMap.put(urlPath, resolvedHandler);
			if (logger.isInfoEnabled()) {
				logger.info("Mapped URL path [" + urlPath + "] onto " + getHandlerDescription(handler));
			}
		}
	}
}

################################################################################################################################################
#######################################################################    第五步   ############################################################
################################################################################################################################################
private void initHandlerAdapters(ApplicationContext context) {
	this.handlerAdapters = null;

	if (this.detectAllHandlerAdapters) {
		Map<String, HandlerAdapter> matchingBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerAdapter.class, true, false);
		if (!matchingBeans.isEmpty()) {
			this.handlerAdapters = new ArrayList<HandlerAdapter>(matchingBeans.values());
			AnnotationAwareOrderComparator.sort(this.handlerAdapters);
		}
	} else {
		try {
			HandlerAdapter ha = context.getBean(HANDLER_ADAPTER_BEAN_NAME, HandlerAdapter.class);
			this.handlerAdapters = Collections.singletonList(ha);
		} catch (NoSuchBeanDefinitionException ex) {
			// 
		}
	}

	// 默认创建HttpRequestHandlerAdapter、SimpleControllerHandlerAdapter
	if (this.handlerAdapters == null) {
		this.handlerAdapters = getDefaultStrategies(context, HandlerAdapter.class);
		if (logger.isDebugEnabled()) {
			logger.debug("No HandlerAdapters found in servlet '" + getServletName() + "': using default");
		}
	}
}

################################################################################################################################################
#######################################################################    第六步   ############################################################
################################################################################################################################################
private void initHandlerExceptionResolvers(ApplicationContext context) {
	this.handlerExceptionResolvers = null;

	if (this.detectAllHandlerExceptionResolvers) {
		Map<String, HandlerExceptionResolver> matchingBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerExceptionResolver.class, true, false);
		if (!matchingBeans.isEmpty()) {
			this.handlerExceptionResolvers = new ArrayList<HandlerExceptionResolver>(matchingBeans.values());
			AnnotationAwareOrderComparator.sort(this.handlerExceptionResolvers);
		}
	} else {
		try {
			HandlerExceptionResolver her = context.getBean(HANDLER_EXCEPTION_RESOLVER_BEAN_NAME, HandlerExceptionResolver.class);
			this.handlerExceptionResolvers = Collections.singletonList(her);
		} catch (NoSuchBeanDefinitionException ex) {
			// Ignore, no HandlerExceptionResolver is fine too.
		}
	}

	// 创建默认的异常处理AnnotationMethodHandlerExceptionResolver、ResponseStatusExceptionResolver、DefaultHandlerExceptionResolver。
	if (this.handlerExceptionResolvers == null) {
		this.handlerExceptionResolvers = getDefaultStrategies(context, HandlerExceptionResolver.class);
		if (logger.isDebugEnabled()) {
			logger.debug("No HandlerExceptionResolvers found in servlet '" + getServletName() + "': using default");
		}
	}
}


################################################################################################################################################
#######################################################################    第七步   ############################################################
################################################################################################################################################
private void initRequestToViewNameTranslator(ApplicationContext context) {
	try {
		this.viewNameTranslator = context.getBean(REQUEST_TO_VIEW_NAME_TRANSLATOR_BEAN_NAME, RequestToViewNameTranslator.class);
		if (logger.isDebugEnabled()) {
			logger.debug("Using RequestToViewNameTranslator [" + this.viewNameTranslator + "]");
		}
	} catch (NoSuchBeanDefinitionException ex) {
		this.viewNameTranslator = getDefaultStrategy(context, RequestToViewNameTranslator.class);
		if (logger.isDebugEnabled()) {
			logger.debug("Unable to locate RequestToViewNameTranslator with name '" + REQUEST_TO_VIEW_NAME_TRANSLATOR_BEAN_NAME + "': using default [" + this.viewNameTranslator + "]");
		}
	}
}

################################################################################################################################################
#######################################################################    第八步   ############################################################
################################################################################################################################################

DefaultRequestToViewNameTranslator
private void initViewResolvers(ApplicationContext context) {
	this.viewResolvers = null;

	if (this.detectAllViewResolvers) {
		Map<String, ViewResolver> matchingBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(context, ViewResolver.class, true, false);
		if (!matchingBeans.isEmpty()) {
			this.viewResolvers = new ArrayList<ViewResolver>(matchingBeans.values());
			AnnotationAwareOrderComparator.sort(this.viewResolvers);
		}
	} else {
		try {
			ViewResolver vr = context.getBean(VIEW_RESOLVER_BEAN_NAME, ViewResolver.class);
			this.viewResolvers = Collections.singletonList(vr);
		}
		catch (NoSuchBeanDefinitionException ex) {
			// 
		}
	}

	// 创建默认的DefaultRequestToViewNameTranslator。
	if (this.viewResolvers == null) {
		this.viewResolvers = getDefaultStrategies(context, ViewResolver.class);
		if (logger.isDebugEnabled()) {
			logger.debug("No ViewResolvers found in servlet '" + getServletName() + "': using default");
		}
	}
}


################################################################################################################################################
#######################################################################    第九步   ############################################################
################################################################################################################################################
private void initFlashMapManager(ApplicationContext context) {
	try {
		this.flashMapManager = context.getBean(FLASH_MAP_MANAGER_BEAN_NAME, FlashMapManager.class);
		if (logger.isDebugEnabled()) {
			logger.debug("Using FlashMapManager [" + this.flashMapManager + "]");
		}
	} catch (NoSuchBeanDefinitionException ex) { 
		this.flashMapManager = getDefaultStrategy(context, FlashMapManager.class);
		if (logger.isDebugEnabled()) {
			logger.debug("Unable to locate FlashMapManager with name '" + FLASH_MAP_MANAGER_BEAN_NAME + "': using default [" + this.flashMapManager + "]");
		}
	}
}

