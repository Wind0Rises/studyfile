dubbo的版本：2.7.5


OneTimeExecutionApplicationContextEventListener


DubboBootstrapApplicationListener


一、服务的导出。

/**
 *
 *
 *
 */
location：DubboBootstrapApplicationListener
public void onApplicationContextEvent(ApplicationContextEvent event) {
	if (event instanceof ContextRefreshedEvent) {
		onContextRefreshedEvent((ContextRefreshedEvent) event);
	} else if (event instanceof ContextClosedEvent) {
		onContextClosedEvent((ContextClosedEvent) event);
	}
}


/**
 *
 *
 *
 */
location：DubboBootstrapApplicationListener
private void onContextRefreshedEvent(ContextRefreshedEvent event) {
	dubboBootstrap.start();
}


/**
 *
 */
location：DubboBootstrap
public DubboBootstrap start() {
	if (started.compareAndSet(false, true)) {
		// ##################################################
		// #          	 		 初始化操作					#
		// ##################################################
		initialize();
		if (logger.isInfoEnabled()) {
			logger.info(NAME + " is starting...");
		}
		
		// ##################################################
		// #          	  Dubbo 服务导出操作				#
		// ##################################################
		exportServices();

		// Not only provider register
		if (!isOnlyRegisterProvider() || hasExportedServices()) {
			// 2. export MetadataService
			exportMetadataService();
			//3. Register the local ServiceInstance if required
			registerServiceInstance();
		}

		referServices();

		if (logger.isInfoEnabled()) {
			logger.info(NAME + " has started.");
		}
	}
	return this;
}


/**
 * 获取所有的服务，并进行导出服务。
 */
location：DubboBootstrap
private void exportServices() {
	configManager.getServices().forEach(sc -> {
		// 01、为每个服务设置DubboBoostrap。
		ServiceConfig serviceConfig = (ServiceConfig) sc;
		serviceConfig.setBootstrap(this);

		// 通过与异步导出不同的处理。
		if (exportAsync) {
			ExecutorService executor = executorRepository.getServiceExporterExecutor();
			Future<?> future = executor.submit(() -> {
				sc.export();
			});
			asyncExportingFutures.add(future);
		} else {
			sc.export();
			exportedServices.add(sc);
		}
	});
}



#####################################################################
#						每个服务导出的具体的操作					#
#####################################################################
/**
 * 每个服务导出的具体操作。
 */
location：ServiceConfig
public synchronized void export() {
	// 判断是否可以导出
	if (!shouldExport()) {
		return;
	}

	// 如果没有DubboBootstrap，获取并创建一个DubboBootstrap。
	if (bootstrap == null) {
		bootstrap = DubboBootstrap.getInstance();
		bootstrap.init();
	}

	checkAndUpdateSubConfigs();
	
	// 组织服务源数据。
	serviceMetadata.setVersion(version);
	serviceMetadata.setGroup(group);
	serviceMetadata.setDefaultGroup(group);
	serviceMetadata.setServiceType(getInterfaceClass());
	serviceMetadata.setServiceInterfaceName(getInterface());
	serviceMetadata.setTarget(getRef());

	if (shouldDelay()) {
		DELAY_EXPORT_EXECUTOR.schedule(this::doExport, getDelay(), TimeUnit.MILLISECONDS);
	} else {
		doExport();
	}
}

/**
 * 每个服务导出的具体操作。
 */
location：ServiceConfig
private void checkAndUpdateSubConfigs() {
	// 
	completeCompoundConfigs();
	
	// 设置provider。
	checkDefault();
	
	// 检查设置protocol。
	checkProtocol();
	
	// 检查设置register
	if (!isOnlyInJvm()) {
		checkRegistry();
	}
	
	this.refresh();

	if (StringUtils.isEmpty(interfaceName)) {
		throw new IllegalStateException("<dubbo:service interface=\"\" /> interface not allow null!");
	}

	if (ref instanceof GenericService) {
		interfaceClass = GenericService.class;
		if (StringUtils.isEmpty(generic)) {
			generic = Boolean.TRUE.toString();
		}
	} else {
		try {
			interfaceClass = Class.forName(interfaceName, true, Thread.currentThread()
					.getContextClassLoader());
		} catch (ClassNotFoundException e) {
			throw new IllegalStateException(e.getMessage(), e);
		}
		checkInterfaceAndMethods(interfaceClass, getMethods());
		checkRef();
		generic = Boolean.FALSE.toString();
	}
	if (local != null) {
		if ("true".equals(local)) {
			local = interfaceName + "Local";
		}
		Class<?> localClass;
		try {
			localClass = ClassUtils.forNameWithThreadContextClassLoader(local);
		} catch (ClassNotFoundException e) {
			throw new IllegalStateException(e.getMessage(), e);
		}
		if (!interfaceClass.isAssignableFrom(localClass)) {
			throw new IllegalStateException("The local implementation class " + localClass.getName() + " not implement interface " + interfaceName);
		}
	}
	if (stub != null) {
		if ("true".equals(stub)) {
			stub = interfaceName + "Stub";
		}
		Class<?> stubClass;
		try {
			stubClass = ClassUtils.forNameWithThreadContextClassLoader(stub);
		} catch (ClassNotFoundException e) {
			throw new IllegalStateException(e.getMessage(), e);
		}
		if (!interfaceClass.isAssignableFrom(stubClass)) {
			throw new IllegalStateException("The stub implementation class " + stubClass.getName() + " not implement interface " + interfaceName);
		}
	}
	checkStubAndLocal(interfaceClass);
	ConfigValidationUtils.checkMock(interfaceClass, this);
	ConfigValidationUtils.validateServiceConfig(this);
	appendParameters();
}

/**
 * 每个服务导出的具体操作。
 */
location：ServiceConfig
public void refresh() {
	Environment env = ApplicationModel.getEnvironment();
	try {
		CompositeConfiguration compositeConfiguration = env.getConfiguration(getPrefix(), getId());
		Configuration config = new ConfigConfigurationAdapter(this);
		if (env.isConfigCenterFirst()) {
			// The sequence would be: SystemConfiguration -> AppExternalConfiguration -> ExternalConfiguration -> AbstractConfig -> PropertiesConfiguration
			compositeConfiguration.addConfiguration(4, config);
		} else {
			// The sequence would be: SystemConfiguration -> AbstractConfig -> AppExternalConfiguration -> ExternalConfiguration -> PropertiesConfiguration
			compositeConfiguration.addConfiguration(2, config);
		}

		Method[] methods = getClass().getMethods();
		for (Method method : methods) {
			if (MethodUtils.isSetter(method)) {
				try {
					String value = StringUtils.trim(compositeConfiguration.getString(extractPropertyName(getClass(), method)));
					if (StringUtils.isNotEmpty(value) && ClassUtils.isTypeMatch(method.getParameterTypes()[0], value)) {
						method.invoke(this, ClassUtils.convertPrimitive(method.getParameterTypes()[0], value));
					}
				} catch (NoSuchMethodException e) {
					logger.info("Failed to override the property " + method.getName() + " in " + this.getClass().getSimpleName() + ", please make sure every property has getter/setter method provided.");
				}
			} else if (isParametersSetter(method)) {
				String value = StringUtils.trim(compositeConfiguration.getString(extractPropertyName(getClass(), method)));
				if (StringUtils.isNotEmpty(value)) {
					Map<String, String> map = invokeGetParameters(getClass(), this);
					map = map == null ? new HashMap<>() : map;
					map.putAll(convert(StringUtils.parseParameters(value), ""));
					invokeSetParameters(getClass(), this, map);
				}
			}
		}
	} catch (Exception e) {
		logger.error("Failed to override ", e);
	}
}