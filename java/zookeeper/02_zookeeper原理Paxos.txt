零、Paxos算法解决的问题：
	在常见的分布式系统中，总会发生诸如机器宕机或网络异常（包括消息的延迟、丢失、重复、乱序，还有网络分区）等情况。Paxos算法需要解决的问题就是如何在一个
	可能发生上述异常的分布式系统中，快速且正确地在集群内部对某个数据的值达成一致，并且保证不论发生以上任何异常，都不会破坏整个系统的一致性。



一、Paxos算法理解。
	1、Paxos算法目标
		让他们按照少数服从多数的方式，最终达成一致意见。
	
	
	2、具体内容情况
		* 在整个提议和投票过程中，主要的角色就是“提议者”（向“接受者”提出提议）和“接受者”（收到“提议者”的提议后，向“提议者”表达自己的意见）。 
		
		
	3、算法的大致情况（这个是理解的情况，和paxos实际演变是有区别的）
		第一阶段：因为存在多个“提议者”，如果都提意见，那么“接受者”接受谁的不接受谁的？太混乱了。所以，要先明确哪个“提议者”是意见领袖有权提出提议，
			未来，“接受者”们就主要处理这个“提议者”的提议了。
			
		第二阶段：由上阶段选出的意见领袖提出提议，“接受者”反馈意见。如果多数“接受者”接受了一个提议，那么提议就通过了。
		
		
	4、重要内容
		1）：怎么明确意见领袖呢？通过编号。每个“提议者”在第一阶段先报个号，谁的号大，谁就是意见领袖。如果不好理解，可以想象为贿选。每个提议者先拿着钞票贿赂
			一圈“接受者”，谁给的钱多，第二阶段“接受者”就听谁的。（注：这里和下文提到的“意见领袖”，并不是一个新的角色，而是代表在那一轮贿赂成功的“提议者”。所
			以，请把意见领袖理解为贿赂中胜出的“提议者”即可）。
			
		2）：有个跟选举常识不一样的地方，就是每个“提议者”不会执着于让自己的提议通过，而是每个“提议者”会执着于让提议尽快达成一致意见。所以，为了这个目标，如果
			“提议者”在贿选的时候，发现“接受者”已经接受过前面意见领袖的提议了，即便“提议者”贿选成功，也会默默的把自己的提议改为前面意见领袖的提议。所以一旦贿赂
			成功，胜出的“提议者”再提出提议，提议内容也是前面意见领袖的提议。
			
		3）：钱的多少很重要，如果钱少了，无论在第一还是第二阶段“接受者”都不会尿你，直接拒绝。
		
		4）：上面2）中讲到，如果“提议者”在贿选时，发现前面已经有意见领袖的提议，那就将自己的提议默默改成前面意见领袖的提议。这里有一种情况，如果你是“提议者”，
			在贿赂的时候，“接受者1”跟你说“他见过的意见领袖的提议是方案1”，而“接受者2”跟你说“他见过的意见领袖提议是方案2”，你该怎么办？这时的原则也很简单，还是：
			钱的多少很重要！你判断一下是“接受者1”见过的意见领袖有钱，还是“接受者2”见过的意见领袖有钱？如何判断呢？因为“接受者”在被“提议者”贿赂的时候，自己会记
			下贿赂的金额。所以当你贿赂“接受者”时，一旦你给的贿赂多而胜出，“接受者”会告诉你两件事情：a.前任意见领袖的提议内容（如果有的话），b.前任意见领袖当时
			贿赂了多少钱。这样，再面对刚才的情景时，你只需要判断一下“接受者1”和“接受者2”告诉你的信息中，哪个意见领袖当时给的钱多，那你就默默的把自己的提议，改
			成那个意见领袖的提议。这时就形成了一种博弈：a.上一个意见领袖要赶在土豪“提议者”贿赂到“接受者”前，赶到“接受者”面前让他接受自己的提议，否则会因为自己
			的之前贿赂的钱比土豪少而被拒绝。b.土豪“提议者”要赶在上一个意见领袖将提议传达给“接受者”前，贿赂到“接受者”，否则土豪“提议者”即便贿赂成功，也要默默的
			将自己的提议改为前任意见领袖的提议。这整个博弈的过程，最终就看这两个“提议者”谁的进展快了。但最终一定会有一个意见领袖，先得到多数“接受者”的认可，那
			他的提议就胜出了。
		
		
	5、总结
		Paxos算法就下面这么几个原则：
		1）：Paxos算法包括两个阶段：第一个阶段主要是贿选，还没有提出提议；第二个阶段主要根据第一阶段的结果，明确接受谁的提议，并明确提议的内容是什么（这个提议
		可能是贿选胜出“提议者”自己的提议，也可能是前任意见领袖的提议，具体是哪个提议，见下面第3点原则）。
		2）：编号（贿赂金额）很重要，无论在哪个阶段，编号（贿赂金额）小的，都会被鄙视（被拒绝）。
		3）在第一阶段中，一旦“接受者”已经接受了之前意见领袖的提议，那后面再来找这个“接受者”的“提议者”，即便在贿赂中胜出，也要被洗脑，默默将自己的提议改为前任意
		见领袖的提议，然后他会在第二阶段提出该提议（也就是之前意见领袖的提议，以力争让大家的意见趋同）。如果“接受者”之前没有接受过任何提议，那贿选胜出的“提议者”
		就可以提出自己的提议了。
		
		
		
		
二、实例
	【【【非常好的博客】】】https://www.zhihu.com/question/19787937/answer/107750652
	
	
三、实际算法过程
	在该算法中，有三种参与角色：Proposer	[ /prəˈpoʊzər/]  要保人；申请人；提案人、
								Acceptor	[ək'septə]		接收人 、
								Learner		[lɜːnə(r)]   		初学者，学习者
	一个进程可能充当不同角色。
	

	
	如果我们希望即使只有一个Proposer提出了一个value，该value也最终被选定。
	P1：一个Acceptor必须接受它收到的第一个提案。
	
	
	一个提案被选定需要被半数以上的Acceptor接受   ----》 一个Acceptor必须能够接受不止一个提案
	
	
	虽然允许多个提案被选定，但必须保证所有被选定的提案都具有相同的value值。否则又会出现不一致。
	
	如果一个天
	
	使用一个全局的编号来唯一标识每一个被Acceptor批准的提案。
	
	下面这些话是站在Acceptor角度说的。
	p2：如果编号为M0、value值为V0的提案（即为[M0、V0]）被选定了，那么所有比编号M0更高的，且被选定的提案，其Value值必须也是V0.
	
	对Acceptor进行约束。
	p2a：如果编号为M0、value值为V0的提案（即为[M0、V0]）被选定了，那么所有比编号M0更高的，且被Acceptor选定的提案，其Value值也是V0。
	
	----》
	这里会有一种情况：
		假设总的有5个Acceptor。Proposer2提出[M1,V1]的提案，Acceptor2-5（半数以上）均接受了该提案，于是对于Acceptor2-5和Proposer2来讲，它们都认为V1被选定。
		Acceptor1刚刚从宕机状态恢复过来（之前Acceptor1没有收到过任何提案），此时Proposer1向Acceptor1发送了[M2,V2]的提案（V2≠V1且M2>M1），对于Acceptor1来讲，
		这是它收到的第一个提案。根据P1（一个Acceptor必须接受它收到的第一个提案。）,Acceptor1必须接受该提案！同时Acceptor1认为V2被选定。这就出现了两个问题：
			1、Acceptor1认为V2被选定，Acceptor2~5和Proposer2认为V1被选定。出现了不一致。
			2、V1被选定了，但是编号更高的被Acceptor1接受的提案[M2,V2]的value为V2，且V2≠V1。这就跟P2a（如果某个value为v的提案被选定了，那么每个编号更高的
			被Acceptor接受的提案的value必须也是v）矛盾了。

		所以就要对Proposer进行约束。
	
	对Proposer进行约束。
	p2b：如果一个提案[M0、V0]被选定以后，那么之后任何Proposer产生的更高编号的提案，其Value都为V0。
	
	
	这也就有另一个问题：如何确保在某个value为v的提案被选定后，Proposer提出的编号更高的提案的value都是v呢？
	P2c：对于任意的N和V，如果提案[N, V]被提出，那么存在一个半数以上的Acceptor组成的集合S，满足以下两个条件中的任意一个：
		S中每个Acceptor都没有接受过编号小于N的提案。
		S中Acceptor接受过的最大编号的提案的value为V。
		
	
	如何生成提案
		为了满足P2b，这里有个比较重要的思想：Proposer生成提案之前，应该先去『学习』已经被选定或者可能被选定的value，然后以该value作为自己提出的提案的value。
		如果没有value被选定，Proposer才可以自己决定value的值。这样才能达成一致。这个学习的阶段是通过一个『Prepare请求』实现的。
		
		
		于是我们得到了如下的提案生成算法：

			Proposer选择一个新的提案编号N，然后向某个Acceptor集合（半数以上）发送请求，要求该集合中的每个Acceptor做出如下响应（response）。
				(a) 向Proposer承诺保证不再接受任何编号小于N的提案。
				(b) 如果Acceptor已经接受过提案，那么就向Proposer响应已经接受过的编号小于N的最大编号的提案。

				
			【Prepare请求：学习过程】
			【Accept请求】
				
				
			我们将该请求称为编号为N的Prepare请求。
				* 如果Proposer收到了半数以上的Acceptor的响应，那么它就可以生成编号为N，Value为V的提案[N,V]。这里的V是所有的响应中编号最大的提案的Value。
				如果所有的响应中都没有提案，那 么此时V就可以由Proposer自己选择。
				* 生成提案后，Proposer将该提案发送给半数以上的Acceptor集合，并期望这些Acceptor能接受该提案。我们称该请求为Accept请求。（注意：此时接受
				Accept请求的Acceptor集合不一定是之前响应Prepare请求的Acceptor集合）
	
	
	
	Paxos算法分为两个阶段。具体如下：
		阶段一：
			(a)Proposer选择一个提案编号N，然后向半数以上的Acceptor发送编号为N的Prepare请求。
			(b)如果一个Acceptor收到一个编号为N的Prepare请求，且N大于该Acceptor已经响应过的所有Prepare请求的编号，那么它就会将它已经接受过的编号最大的提案
			（如果有的话）作为响应反馈给Proposer，同时该Acceptor承诺不再接受任何编号小于N的提案。

		阶段二：
			(a)如果Proposer收到半数以上Acceptor对其发出的编号为N的Prepare请求的响应，那么它就会发送一个针对[N,V]提案的Accept请求给半数以上的Acceptor。注
			意：V就是收到的响应中编号最大的提案的value，如果响应中不包含任何提案，那么V就由Proposer自己决定。
			(b)如果Acceptor收到一个针对编号为N的提案的Accept请求，只要该Acceptor没有对编号大于N的Prepare请求做出过响应，它就接受该提案。
			
			
			
	Learner学习被选定的value
		
		learner获取一个已经被选定的提案的前提是，该提案已经被半数以上的Acceptor批准。因此，最简单的做法就是一旦
		Acceptor批准了一个提案，就将该提案发送给所有的learner。
		
		让所有的Acceptor将他们对提案批准情况，统一发送给一个特定的Learner（主Learner），主Learner在发送给其他Learner。单点问题
		
		
		让所有的Acceptor将他们对提案批准情况，统一发送给一个特定的Learner集合。这个集合在通知给其他Learner。