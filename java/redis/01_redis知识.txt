redis-server redis.conf
	windows下的redis默认加载redis.windows-service.conf文件。


	
	
	
	

string:
	普通字符串操作。
	
	命令：
		set key value [ex seconds] [px milliseconds] [nx | xx]
			将字符串与key关联，如果key已经存在将覆盖旧值。当set命令对一个带有生存时间（TTL）的键进行设置之后， 该键原有的TTL将被清除。
			ex：设置过期时间，单位为秒，不能是浮点类型的。
			px：设置过期时间，单位为毫秒，不能是浮点类型的。
			nx：当且仅当key不存在时，进行操作。
			xx：当且仅当key存在时，进行操作。
			在Redis 2.6.12版本以前，set命令总是返回ok。
			从Redis 2.6.12版本开始，set命令只在设置操作成功完成时才返回ok;如果命令使用了nx或者xx选项，但是因为条件没达到而造成设置操作未执行，那么命令将返回空批量回复（NULL Bulk Reply）。
		
	
		setnx key value 
			当且仅当key不存在时，进行插入操作。
			成功返回1；失败返回0。

		setex key seconds value
			插入一条数据，并未其设置过期时间，单位为秒。如果key已经存在，进行覆盖操作。
			成功返回ok，当seconds不合法时，返回一个错误。

		psetex key milliseconds value
			插入一条数据，并未其设置过期时间，单位为毫秒。如果key已经存在，进行覆盖操作。
			成功返回ok，当seconds不合法时，返回一个错误。

		get key
			获取key对应的value值，
			如果key不存在返回nil，否则返回key的值，如果key不是string类型，返回一个错误。

		getset key value
			先获取key的旧值，然后再把新值设置进去。
			如果key值不存在，返回nil；否则返回key的旧值。key如果不是字符串，则报错。

		strlen key
			查看key对应得value的字符串长度。
			如果key不存在返回0；否则返回key对应的value的长度。key如果不是字符串，则报错。

		append key value	
			如果键key已经存在并且它的值是一个字符串，append命令将把value追加到键key现有值的末尾。
			如果key不存在，append就简单将key对应的值设置为value。
			返回追加之后的value的长度。

		setrange key offset value
			从偏移量offset开始，用value参数覆盖key存储的字符串。注意：如果原有的value从offset开始到最后的长度大于setrange的value，则只会覆盖原有的部分数据，后面的
			将不会改变。【(set greet liuweian) (setrange greet 2 wo) (get greet)  结果  liwoeian】
			key不存在时，做空白处理。
			返回修改之后的value值的长度。

		getrange key start end
			获取从key对应的value值的指定返回的结果。（start、end都包含。下标从0开始）
			负数偏移量表示从字符串的末尾开始计数，-1表示最后一个字符，-2 表示倒数第二个字符，以此类推。
			返回截取的值，如果end大于总长度，返回全部数据，如果start大于总长度，返回空字符串。

		incr key	
			对给定key的value进行加1操作。
			返回操作后的value值。如果value是不可操作的，返回一个错误，如果key不存在，那么它的值会先被初始化为0， 然后再执行incr命令。

		incrby key increment
			对给定key的value进行加increment（如果increment为负值就是一个减操作）操作。本操作的值increment限制在64位(bit)有符号数字表示之内。
			返回操作后的value值。如果value是不可操作的，返回一个错误；如果key不存在，那么它的值会先被初始化为0， 然后再执行incrby命令。

		incrbyfloat key  increment
			为键key储存的值加上浮点数增量increment。
			如果键key不存在，那么incrbyfloat会先将键key的值设为0，然后再执行加法操作。
			如果命令执行成功，那么键key的值会被更新为执行加法计算之后的新值，并且新值会以字符串的形式返回给调用者。

		decr key
			对给定key的value进行减1操作。
			返回操作后的value值。如果value是不可操作的，返回一个错误，如果key不存在，那么它的值会先被初始化为0， 然后再执行decr命令。

		decrby key decrement
			对给定key的value进行减去decrement（如果increment为负值就是一个加操作）操作。本操作的值decrement限制在64位(bit)有符号数字表示之内。
			返回操作后的value值。如果value是不可操作的，返回一个错误；如果key不存在，那么它的值会先被初始化为0， 然后再执行decrby命令。
			
		mset key value [key value ...]
			同时为多个键设置值。mset是一个原子性(atomic)操作，所有给定键都会在同一时间内被设置，不会出现某些键被设置了但是另一些键没有被设置的情况。
			mset命令总是返回ok。
		
		msetnx key value [key value ...]
			当且仅当所有给定键都不存在时，为所有给定键设置值。
			即使只有一个给定键已经存在， msetnx命令也会拒绝执行对所有键的设置操作。
			msetnx是一个原子性(atomic)操作，所有给定键要么就全部都被设置，要么就全部都不设置，不可能出现第三种状态。

		mget key [key ...]
			获取多个值，如果key不存在就返回nil.

list：
	有序可以重复的。
	
	命令：	
		lpush key value[value ...]
			将一个值或者多个值插入列表【表头，left】key中。
			如果有多个值，那么各个value按照从左到右的顺序依次插入表头，多个值插入时，具有原子性，如果插入多个值都会插入，如果失败都会失败。
			如果key不存在，会创建一个新的列表。
			返回执行后的列表key的长度。
			
		lpushx
			将值value插入到列表key的【表头】，当且仅当key存在并且是一个列表。
			返回执行后的列表key的长度。
			
		rpush key value[value ...]
			将一个值或者多个值插入列表【表尾，right】key中。
			如果有多个值，那么各个value按照从左到右的顺序依次插入表头，多个值插入时，具有原子性，如果插入多个值都会插入，如果失败都会失败。
			如果key不存在，会创建一个新的列表。
			返回执行后的列表key的长度。	
		
		rpushx
			将值value插入到列表key的【表尾】，当且仅当key存在并且是一个列表。
			返回执行后的列表key的长度。	
		
		lpop key
			移除并返回列表key的表头元素。如果key不存在返回nil。
			
		rpop key
			移除并返回列表key的表尾元素。如果key不存在返回nil。	
			
		rpoplpush source distination
			从source的表尾移除一个元素放到distination列表中。
			如果source为空，值nil被返回，并不会做任何操作。
			如果source和distination是同一个，则列表中的表尾元素被移动到表头，并返回该元素，可以把这种特殊情况视作列表的旋转(rotation)操作。
			返回被弹出的元素。
			
			
		lrem key count value
			移除列表中与参数value相等的元素。
			count > 0 : 从表头开始向表尾搜索，移除与value相等的元素，数量为count。
			count < 0 : 从表尾开始向表头搜索，移除与value相等的元素，数量为count的绝对值。	
			count = 0 : 移除表中所有与 value 相等的值。
			被移除元素的数量。因为不存在的key被视作空表(empty list)，所以当key不存在时，lrem命令总是返回0。
			
		llen key
			返回列表key的长度，
			
		lindex key index
			返回列表key中，下标为index的元素。下标从0开始。
			负数下标：以-1表示列表的最后一个元素，-2表示列表的倒数第二个元素，以此类推。
			列表中下标为index的元素。 如果index参数的值不在列表的区间范围内，返回 nil。
		
		linsert key before|after pivot value
			将值value插入到列表key当中，位于值pivot 之前或之后。
			当pivot不存在于列表key时，不执行任何操作。当key不存在时，key被视为空列表，不执行任何操作。如果key不是列表类型，返回一个错误。
			如果命令执行成功，返回插入操作完成之后，列表的长度。如果没有找到pivot，返回-1。 如果key不存在或为空列表，返回0。
			
		lset key index value
			相等于一个更新操作。把key列表中，下标为index的值设置为value，如果index不在返回，或者key列表不存在，返回错误。
			
		lrange key start stop
			截取key列表中下标在start和stop之间的数据，包含start和stop。
			入股stop大于end，返回只会截取到end。
			
		ltrim key start stop
			对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。
			执行成功返回ok。
			
		blpop key [key ..] timeout
			以堵塞方式移除元素到表头。
			
		brpop key [key ..] timeout
			以堵塞方式移除元素到表尾。
			
		brpoplpush source destination timeout
			rpoplpush的堵塞模式。

			
hash表：
	类似java里的map。总体来看想一个包括map的list。

	命令：
		hset key filed value
			向key哈希表中插入一个字段为filed值为vaule的数据。如果key哈希表不存在，则创建key哈希表。
			如果域已经存在，则更新域对应的值，并返回0。
			返回：成功返回1；失败或者已经存在返回0。
			
		hsetnx key filed value
			向key哈希表中插入一个字段为filed值为vaule的数据，当且仅当filed不存在时，进行插入操作。
			返回设置成功时返回1， 在给定域已经存在而放弃执行设置操作时返回0。
			
		hget key filed
			返回给定的哈希表中的filed对应的值，如果field不存在或者是key不存在，返回nil。
			
		hexists key field 
			返回给定哈希表下的是否存在给定field。
			返回：如果存在返回1，不存在返回0；
			
		hdel key filed1 [field2 ..]
			删除给定哈希表下一个或者多个域，如果域不存在则忽略
			返回：被成功移除的域的数量，不包括被忽略的域。
			
		hlen key
			返回哈希表中的序列的数列。
			
		hstrlen key field
			返回给定哈希表中对应的域的值得字符长度。如果key不存在，那么返回0。
		
		hincrby key field increment
			将给定哈希表的给定域的值加上increment。如果filed对应的值不是64位有符号的数字内，都会报错。
			如果field不存在，先新建一个filed并把值设置为0，然后再操作。
			返回操作过后的value值。
			
		hincrbyfload key field increment 
			将给定哈希表的给定域的值加上increment。
			如果field不存在，先新建一个filed并把值设置为0，然后再操作。
			返回操作过后的value值。
			
		hmset key filed1 value1 [field2 value2 ...]
			一次插入多个值，如果成功返回ok。当key不是哈希表(hash)类型时，返回一个错误
			
		hmget key filed1 [field2 ...]
			一次获取入多个值，如果filed不存在返回nil。
			
		hkeys key【key是具体的值，不能使用正则表达式】
			返回哈希表key中的所有【域】。
			
		hvals key 
			返回哈希表key中所有【域的值】。
			
		hgetall key
			返回哈希表key中，所有的域和值。
			
		hscan key cursor [match pattern] [count count]
				
		
Set集合()：
	集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。
	
	命令：
		sadd：sadd key member1 [member2 ...]
			将一个或者多个member加入到集合key中，如果member已经存在于集合中，则直接忽略。当key不是集合类型报错。
			
		sismember key member
			判断member是否存在集合key中，如果存在返回1，如果不存在返回0；
			
		smembers key
			返回key集合中所有成员。
			
		spop key
			移除并返回集合key中随机一个成员。返回被移除的随机元素。 当key不存在或key是空集时，返回 nil。
		
		srandmember key [count]
			随机返回key集合中的元素，并不会把元素删除。如果count是小于集合总数并且大于0，会随机返回count个元素；如果count为负数，或者大于集合元素，则返回全部元素。
		
		srem key member1 [member2 ...]
			移除一个或者多个元素，并返回移除的个数。不存在的member元素会被忽略，这时返回的值是不包含被忽略的元素的。
			
		smove source destination member
			把member从source集合移动到destination集合中，如果source集合不存在或者source集合中没有member元素，smove不进行任何操作，返回0；
			否则，member元素从source集合中被移除，并添加到destination集合中去。如果destination集合中已经存在member元素，只会把source集合中的member元素删除。
			
		scard key
			查询key集合中元素的个数。
			
		sinter key1 [key2 ..]
			返回给定集合的交集。如果只有一个集合，返回结合的全部元素；如果有多个结合。
			
		sinterstore destination key1 [key2 ..]
			把给定集合的交集保存到destination集合中。如果destination集合已经存在，将其覆盖。
			
		sunion key1 [key2 ...]
			返回给定集合的并集。
			
		sunionstore destination key1 [key2 ...]
			把给定集合的并集存放在destination结合中。
			
		sdiff key1 [key2 ...]
			返回key1集合中没有在后面集合中出现过的元素。
			
		sdiffstore destination key1 [key2 ...]
			把key1集合中没有在后面集合中出现过的元素保存到destination集合中。
		

zset集合()：
	元素不能重复，使用类似权重的进行排序。

		zadd key score member1 [score member2 ...]
		例： zadd ordered 1 value1  4 value2
			返回插入的集合的个数。如果插入的元素已经存在，不计入统计，这个时候回更新对应的值。position值可以是整数值或双精度浮点数。
		
		
		zscore key member
			返回给定集合中给定元素的score的值。
			如果key集合不存在或者是member元素不存在，返回nil
			
		zincrby key increment member
			为有序集合key的member元素的score值增加increment。可以通过一个负数减去一个值。
			当key不存在，或member不是key的成员时，ZINCRBY key increment member 等同于 ZADD key increment member。
			返回更新后的score的值。
			
		zcard key
			返回集合key中元素的个数。
			返回满足条件的数据个数
			
		zcount key min max
			返回集合key中score在max和min之间的元素个数，包含min和max
			
		zrange key start end [withscores]    【key start相当于是数组下标】
			返回有序集key中，指定区间内的成员。其中成员的位置按score值递增(从小到大)来排序
			如果想要score也返回可以在最后加上withscores。start和end相当于数组的下标，从0开始，start和end都是闭区间。
			
		zrevrange key start end [withscores]  【key start相当于是数组下标】
			返回有序集key中，指定区间内的成员。其中成员的位置按score值递减(从大到小)来排序
			如果想要score也返回可以在最后加上withscores。start和end相当于数组的下标，从0开始，start和end都是闭区间。
			
		zrangebyscore key min max [WITHSCORES] [LIMIT offset count]
			返回有序集合score值在min于max之间的值。序集成员按score值递增(从小到大)次序排列。可以使用limit进行类似分页操作。
			min最小值可以使用-inf来表示；max最大值可以使用+inf表示。
			
		zrevrangebyscore key min max [WITHSCORES] [LIMIT offset count] 
			返回有序集合score值在min于max之间的值。序集成员按score值递减(从大到小)次序排列。可以使用limit进行类似分页操作。
			min最小值可以使用-inf来表示；max最大值可以使用+inf表示。
			
		zrank key member
			返回member元素在key集合中的排名，按照score递增排序，需要从0开始。
			如果member不是有序集key的成员，返回nil。
			
		zrevrank key member
			返回member元素在key集合中的排名，按照score递减排序，需要从0开始。
			如果member不是有序集key的成员，返回nil。
			
		zrem key1 member1 [member2 ..]
			移除一个或者多个元素，如果元素不存在，忽略。返回被成功移除的成员的数量，不包括被忽略的成员。
			
		zremrangebyrank key start end
			移除有序集合中，下标区间start和end之间【包括start和end】元素。用0表示第一个元素。
			返回移除的元素个数。
		
		zremrangebyscore key start end
			移除有序集合中，score区间在start和end之间【包括start和end】元素
			返回被移除成员的数量。
			
		zrangebylex key min max [limit offset count]
			
		

事务：

	命令：
		multi
			标记一个事务的开始。事务块内的多条命令会按照先后顺序被放进一个队列当中，最后由EXEC命令原子性(atomic)地执行。
			
		exec
			执行事务块内的所有命令。
			假如某个(或某些) key正处watch命令的监视之下，且事务块中有和这个(或这些)key相关的命令，
			那么exec命令只在这个(或这些)key没有被其他命令所改动的情况下执行并生效，否则该事务被打断(abort)。
			
		discard
			取消事务，放弃执行事务块内的所有命令。
			如果正在使用watch命令监视某个(或某些) key，那么取消所有监视，等同于执行命令unwatch。

		watch key1 [key2 ..]
			监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。
			线程一： 	match test   			  线程二：	match test
						multi								multi
						incr incr							incr incr
															exec  【执行成功】
						exec 【执行失败】
			
		unwatch
			取消watch命令对所有 key 的监视。
			如果在执行watch命令之后，exec命令或discard命令先被执行了的话，那么就不需要再执行unwatch了。
			因为exec命令会执行事务，因此watch命令的效果已经产生了；而discarg命令在取消事务的同时也会取消所有对key的监视，
			因此这两个命令执行之后，就没有必要执行unwatch了。

发布订阅：
	可以模拟MQ行为。
	
	命令：
		publish channel message
			将消息message发布到频道channel。
			返回：接收到消息的订阅者的数量。
		
		subscribe channel1 [channel2 ..]
			订阅一个或者多个频道channel。
			
		psubscribe pattern1 [pattern2 ..]
			订阅一个或者多个符合正则表达式的频道。
			
		unsubscribe channel1 [channel2 ..]
			客户端退订一个或者多个频道
			
		punsubscribe pattern1 [pattern2 ..]
			客户端退订一个或者多个满足正则表达式的频道。
			
		pubsub subcommand [argument [argument]]
			pubsub channels [pattern]
				列出当前的活跃的频道。活跃频道指的是那些至少有一个订阅者的频道， 订阅模式的客户端不计算在内。
			
			pubsub numsub channel1 [channel2 ..]
				查询频道的订阅者的数量。
				
			pubsub numpat
				返回订阅模式的数量。
				client-1：订阅 news.* 和 discount.* 两个模式
				client-2：订阅 tweet.* 一个模式
				pubsub numpat     结果为：3
				client-3：让它也订阅news.*频道
				pubsub numpat     结果为：4
		
		
		
过期操作：

	命令：
		expire key seconds
			为给定key设置生存时间，当key过期时(生存时间为0)，它会被自动删除。【seconds不能是浮点型数字。】
			生存时间可以通过使用DEL命令来删除整个key来移除，或者被SET和GETSET命令覆写(overwrite)，
			这意味着，如果一个命令只是修改(alter)一个带生存时间的key的值而不是用一个新的key值来代替(replace)它的话，那么生存时间不会被改变。
			如果通过rename改变了key的名称，则新的key的过期时间也是与原有key的偶去时间是一样的。
			
		expireat key timestamp
			给key设置过去时间，这个过期时间是一个时间戳，到达这个时间点就过期。
			设置成功返回1，失败返回0。
			
		ttl key
			查询key的过期时间，如果key不存在返回-2，当key没有设置过去时间返回-1，否则以秒为单位返回key的剩余生存时间。
			
		persist key
			移除key的生存时间。表示key永不过期。
			
		pexpire key milliseconds
			以毫米为单位设置过期时间。【milliseconds不能是浮点型数字。】
		
		pexpireat key timestamp	
			以毫秒为单位
		
		pttl
			以秒为单位。
		
	
持久化:
	
	命令：
		save
			save命令执行一个同步保存操作，将当前redis实例的所有数据快照(snapshot)以RDB文件的形式保存到硬盘。
			一般来说，在生产环境很少执行save操作，因为它会阻塞所有客户端，保存数据库的任务通常由bgsave命令异步地执行。然而，如果负责保存数据的后台子进程不幸出现问题时，save可以作为保存数据的最后手段来使用。
			
		bgsave
			在后台异步(Asynchronously)保存当前数据库的数据到磁盘。
			bgsave命令执行之后立即返回OK，然后 Redis fork出一个新子进程，原来的redis进程(父进程)继续处理客户端请求，而子进程则负责将数据保存到磁盘，然后退出。
			
		bgrewriteaof
			
			
		lastsave
			返回最近一次redis成功将数据保存到磁盘上的时间，以UNIX时间戳格式表示。
		

调试：
	
	命令：
		ping 
			使用客户端向redis服务器发送一个ping，如果服务器运作正常的话，会返回一个pong。
			通常用于测试与服务器的连接是否仍然生效，或者用于测量延迟值。
			
		echo
			打印一个特定的信息。以linux中echo命令类似。
			
			
客户端与服务端：
	
	命令：	
		auth password
			如果auth命令给定的密码password和配置文件中的密码相符的话，服务器会返回ok并开始接受命令输入。
			
		quit
			请求服务器关闭与当前客户端的连接。
			
		info [server|clients|memory|persistence|stats|replication|cpu|commandstats|cluster|keyspace|all|default]
			以一种易于解释（parse）且易于阅读的格式，返回关于 Redis 服务器的各种信息和统计数值。
			
		time
			返回当前服务器时间。	
			
		client setname
			为一个客户端连接设置一个名称。
			
		client getname
			返回客户端连接的名称
		
		client kill ip:port
			关闭ip:port的客户端。
			
		client list
			返回所有与该客户端连接的服务端进行连接操作的客户端连接信息。

			
Lua脚本

	命令：
		eval script numkeys key [key ..] arg [arg ..]
			执行script脚本，numkeys指定后面有几个键名，最后是参数值。
			
		evalsha sha1 numkeys key [key ..] arg [arg ..]

		
		
##################################################################################################################################
#######################################    		   常见问题				##########################################################
##################################################################################################################################

一：初级
	1、set、zset、list的区别：
		set：无须不可重复的。
		list：有序可重复的。
		zset：有序不可重复的。
	
	
	2、redis事务原理：
		当一个线程去执行某些业务逻辑，但是这些业务逻辑操作的数据可能被其他线程共享了，这样会引发多线程中数据不一致的情况。
		为了克服这个问题，首先，在线程开始时读取这些多线程共享的数据，并将其保存到当前进程的副本中，我们称为旧值(old value)，watch命令就是这样的一个功能。
		然后，开启线程业务逻辑，由multi命令提供这一功能。在执行更新前，比较当前线程副本保存的旧值和当前线程共享的值是否一致，
		如果不一致，那么该数据已经被其他线程操作过，此次更新失败。
		
		为了保持一致，线程就不去更新任何值，而将事务回滚；
		否则就认为它没有被其他线程操作过，执行对应的业务逻辑，exec 命令就是执行“类似”这样的一个功能。
		
		
	3、如果命令出错事务还会执行吗？
		如果是命令已经入队，但是最后exec执行以后，发现操作命令需要的对象与实际传入的对象不符合，这个时候报错，是不会影响事务的执行的，事务依旧会进行操作。
		如果是命令本身就有问题，导致命令行无法入队，这个时候回导致事务自动退出，并回滚事务，操作不会影响实际的值。
		
	

二：高级	
	1、什么是缓存穿透问题？如何处理缓存穿透问题？
		用户在访问应用时，会把不常改变并且使用频繁的数据缓存起来，如果用户再次访问这些数据，就会直接访问缓存中的数据，并不会直接去数据库查询，只有数据改变
		或者没有缓存的数据才会去数据库查询。可以看出缓存就是访问数据库的防火墙，从而减轻数据库的访问压力。
		造成缓存穿透的原因有：
			1、恶意攻击，猜测你的key命名方式，然后估计使用一个你缓存中不会有的key进行访问。
			2、第一次数据访问，这时缓存中还没有数据，则并发场景下，所有的请求都会压到数据库。
			3、数据库的数据也是空，这样即使访问了数据库，也是获取不到数据，那么缓存中肯定也没有对应的数据。这样也会导致穿透。
			
		解决：规范key的命名规则，对不符合规则的key直接过滤。
			  对数据库没有值的key，也进行缓存，缓存的值为null或者是空字符串，如果数据库的空值很多，注意要设置key的过期时间。
			  启动服务的时候，把使用频繁的并且不经常更新的数据提前缓存到redis中。
			  
			  
	2、缓存雪崩问题，
		
			
	
	
	3、redis集群策略
		* 主从模式：redis的主从模式，使用异步复制，slave节点异步从master节点复制数据，master节点提供读写服务，slave节点只提供读服务
					（这个是默认配置，可以通过修改配置文件slave-read-only控制）。master节点可以有多个从节点。配置一个slave节点只需要
					 在redis.conf文件中指定 slaveof master-ip master-port即可。
					 优点：由于主从模式，slave节点不会进行选举操作，无法在从节点上写东西，从节点是只读状态。主要是备份数据。【slave-read-only yes】
			
			
		* 哨兵模式：主从模式下，如果只有一个哨兵也是可以进行故障转移的。一般情况下都不会只有一个哨兵。
					单master的redis集群，sentinel一般配置三台，避免如果是单sentinel宕机以后无法提供故障转移操作。
					
					sentinel会通过心跳监控集群下的每一台服务，如果有redis服务在规定时间内没有返回给sentinel，这台sentinel会主观认为这台redis已经宕机了sdown
					如果超过sentinel.conf中配置的sentinel服务器个数认为redis服务器sdown了以后，这时sentinel系统会客观认为这台redis已经离线了，--> odown。
					如果这台redis是master，这个时候就会sentinel就会发起故障转移，从slave节点中推选出新的master节点，并把其他从节点挂在新推举出来的master下。
					
		* 集群模式：redis内置数据自动分片机制，集群内部将所有的key映射到16384(10 0000 0000 0000、2的14次方)个Slot中，集群中的每个redis instance负责其中的一
					部分的Slot的读写。
		
		
	4、slave-read-only在集群模式下的作用。
	
	
	5、集群脑裂问题。
	
	
	6、缓存过期策略。
	
	

##################################################################################################################################################################
###########################################################    	         附录				######################################################################
##################################################################################################################################################################
		
附录一：sentinel配置文件：
##################################################################################################################################################################
	# 当前Sentinel服务运行的端口
	port 26379

	# master
	# Sentinel去监视一个名为mymaster的主redis实例，这个主实例的IP地址为本机地址127.0.0.1，端口号为6379，
	# 而将这个主实例判断为失效至少需要2个 Sentinel进程的同意，只要同意Sentinel的数量不达标，自动failover就不会执行
	sentinel monitor mymaster 127.0.0.1 6379 1

	# 指定了Sentinel认为Redis实例已经失效所需的毫秒数。当实例超过该时间没有返回PING，或者直接返回错误，那么Sentinel将这个实例标记为主观下线。
	# 只有一个Sentinel进程将实例标记为主观下线并不一定会引起实例的自动故障迁移：只有在足够数量的Sentinel都将一个实例标记为主观下线之后，
	# 实例才会被标记为客观下线，这时自动故障迁移才会执行。
	sentinel down-after-milliseconds mymaster 5000

	# 指定了在执行故障转移时，最多可以有多少个从Redis实例在同步新的主实例，在从Redis实例较多的情况下这个数字越小，同步的时间越长，完成故障转移所需的时间就越长
	sentinel parallel-syncs mymaster 1

	# 如果在该时间（ms）内未能完成failover操作，则认为该failover失败
	sentinel failover-timeout mymaster 30000

	
	
附录二：查看哨兵模式的命令
#################################################################################################################################################################

	启动一个哨兵：redis-server.exe  ./sentinel.conf  --sentinel
	
	查看一个redis的状态： redis-cli.exe -h ip -p port
						  info replication
						  
								127.0.0.1:6377> info replication
								# Replication
								role:master
								connected_slaves:2
								slave0:ip=127.0.0.1,port=6378,state=online,offset=39590,lag=0
								slave1:ip=127.0.0.1,port=6379,state=online,offset=39590,lag=0
								master_repl_offset:39590
								repl_backlog_active:1
								repl_backlog_size:1048576
								repl_backlog_first_byte_offset:2
								repl_backlog_histlen:39589

								
附录三：redis.conf集群配置
#######################################################################################################################################################################################################################################
	# 如果配置yes则开启集群功能，此redis实例作为集群的一个节点，否则，它是一个普通的单一的redis实例。
	cluster-enabled yes
	
	# 虽然此配置的名字叫"集群配置文件"，但是此配置文件不能人工编辑，它是集群节点自动维护的文件，主要用于记录集群中有哪些节点、他们的状态以及一些持久化参数等，
	# 方便在重启时恢复这些状态。通常是在收到请求之后这个文件就会被更新。
	cluster-config-file cluster-6379.conf

	# 这是集群中的节点能够失联的最大时间，超过这个时间，该节点就会被认为故障。如果主节点超过这个时间还是不可达，则用它的从节点将启动故障迁移，升级成主节点。
	# 注意，任何一个节点在这个时间之内如果还是没有连上大部分的主节点，则此节点将停止接收任何请求。一般设置为15秒即可。
	cluster-node-timeout 15000

	# 如果设置成０，则无论从节点与主节点失联多久，从节点都会尝试升级成主节点。
	# 如果设置成正数，则cluster-node-timeout【乘】cluster-slave-validity-factor得到的时间，是从节点与主节点失联后，此从节点数据有效的最长时间，
	# 超过这个时间，从节点不会启动故障迁移。
	# 假设cluster-node-timeout=5，cluster-slave-validity-factor=10，则如果从节点跟主节点失联超过50秒，此从节点不能成为主节点。
	# 注意，如果此参数配置为非0，将可能出现由于某主节点失联却没有从节点能顶上的情况，从而导致集群不能正常工作，在这种情况下，
	# 只有等到原来的主节点重新回归到集群，集群才恢复运作。
	cluster-slave-validity-factor 10
	
	# 主节点需要的最小从节点数，只有达到这个数，主节点失败时，它从节点才会进行迁移。更详细介绍可以看本教程后面关于副本迁移到部分。
	cluster-migration-barrier 1
	
	# 在部分key所在的节点不可用时，如果此参数设置为"yes"(默认值), 则整个集群停止接受操作；如果此参数设置为”no”，则集群依然为可达节点上的key提供读操作
	cluster-require-full-coverage yes
	
