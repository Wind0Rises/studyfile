
一：初级
	1、set、zset、list的区别：
		set：无须不可重复的。
		list：有序可重复的。
		zset：有序不可重复的。
	
	
	2、redis事务原理：
		当一个线程去执行某些业务逻辑，但是这些业务逻辑操作的数据可能被其他线程共享了，这样会引发多线程中数据不一致的情况。
		为了克服这个问题，首先，在线程开始时读取这些多线程共享的数据，并将其保存到当前进程的副本中，我们称为旧值(old value)，watch命令就是这样的一个功能。
		然后，开启线程业务逻辑，由multi命令提供这一功能。在执行更新前，比较当前线程副本保存的旧值和当前线程共享的值是否一致，
		如果不一致，那么该数据已经被其他线程操作过，此次更新失败。
		
		为了保持一致，线程就不去更新任何值，而将事务回滚；
		否则就认为它没有被其他线程操作过，执行对应的业务逻辑，exec 命令就是执行“类似”这样的一个功能。
		
		
	3、如果命令出错事务还会执行吗？
		如果是命令已经入队，但是最后exec执行以后，发现操作命令需要的对象与实际传入的对象不符合，这个时候报错，是不会影响事务的执行的，事务依旧会进行操作。
		如果是命令本身就有问题，导致命令行无法入队，这个时候回导致事务自动退出，并回滚事务，操作不会影响实际的值。





二、数据持久化
	1)、rdb持久化
		1、什么时候生成rdb文件。
			可以通过save和bgsave，save命令直接阻塞服务器进程，直到rdb文件完毕为止，在服务器阻塞期间，服务器不能处理任何命令。而bgsave会fork()一个子进程，由子进程负责创建rdb文件，服务器
			进程继续处理请求命令。
		
		2、rdb文件结构
		
	
	
	
	2)、aof持久化
		1、aof持久化步骤
			aof持久化功能的实现可以分为命令追加（append）、文件写入、文件通过（sync）三步骤
			
		2、aof重写期间，新增的数据如何操作
			redis设置了一个aof重写缓冲区，服务器会在创建子进程之后开始使用，单redis服务器执行完了一个写命令以后，它会同时将写命令发送给aof缓存区和aof重写缓存区。aof缓存区的内容会定期被写入
			和同步到aof文件中，对现有的文件的处理工作会正常进行。子进程完成重写操作以后会发送一个信号给父进程，父进程会调用一个信号处理函数，处理函数将aof重写缓冲区的内容写入到新的aof文件中
			这是新的aof文件保存的数据和服务中保存的是一直的，然后对新的aof文件改名，原子地覆盖了现有的aof文件。
			
		【note】
			现代操作系统中，当用户调用write函数，将一些数据写入到文件的时候，操作系统通常会把写入的文件暂时保存在一个内存缓存区中里面，等到缓存区的空间被填满、或者超过了指定时限后，才真正的
		将缓冲区中的数据写入磁盘里。所以系统提供了fsync和fdatasync两个同步函数，强制操作系统立刻把缓存区的数据写入磁盘。
		
	
	3、save、bgsave、bgrewritaof三个命令
		* save期间，服务器会堵塞，不会接受任何指令。
		* bgsave处理期间，如果客户端发起save命令，会直接拒绝。服务器禁止save好bgsave同时执行。
		* bgsave处理期间，如果客户端发起bgsave命令，会直接拒绝。服务器禁止两个bgsave同时执行。
		* bgsave处理期间，如果客户端发起bgrewriteaof命令，bgrewriteaof命令会延迟到bgsave执行完成以后。
		* 如果bgrewriteaof处理期间，如果客户端发起bgsave命令，服务器会直接拒绝。【bgsave、bgrewritaof都是fork()子进程进行处理，其并不冲突，知识为了性能考虑，减少大量磁盘IO】
		
	

二：高级	
	1、什么是缓存穿透问题？如何处理缓存穿透问题？
		用户在访问应用时，会把不常改变并且使用频繁的数据缓存起来，如果用户再次访问这些数据，就会直接访问缓存中的数据，并不会直接去数据库查询，只有数据改变
		或者没有缓存的数据才会去数据库查询。可以看出缓存就是访问数据库的防火墙，从而减轻数据库的访问压力。
		造成缓存穿透的原因有：
			1、恶意攻击，猜测你的key命名方式，然后使用一个你缓存中不会有的key进行访问。
			2、第一次数据访问，这时缓存中还没有数据，则并发场景下，所有的请求都会压到数据库。
			3、数据库的数据也是空，这样即使访问了数据库，也是获取不到数据，那么缓存中肯定也没有对应的数据。这样也会导致穿透。
			
		解决：针对一：规范key的命名规则，对不符合规则的key直接过滤。
			  针对二：启动服务的时候，把使用频繁的并且不经常更新的数据提前缓存到redis中。
			  针对三；对数据库没有值的key，也进行缓存，缓存的值为null或者是空字符串，如果数据库的空值很多，注意要设置key的过期时间。
			  
			  
	2、缓存雪崩问题，
		什么是缓存雪崩：指在一个时间段，缓存集中失效。
		布隆过滤器
			
	
	
	3、redis集群策略
		* 主从模式：redis的主从模式，使用异步复制，slave节点异步从master节点复制数据，master节点提供读写服务，slave节点只提供读服务
					（这个是默认配置，可以通过修改配置文件slave-read-only控制）。master节点可以有多个从节点。配置一个slave节点只需要
					 在redis.conf文件中指定 slaveof master-ip master-port即可。
					 优点：由于主从模式，slave节点不会进行选举操作，无法在从节点上写东西，从节点是只读状态。主要是备份数据。【slave-read-only yes】
					 集群脑裂问题：
						min-slave-to-write: 1
						min-slave-max-lag: 10
						只要有一个slave节点，数据复制和同步的延迟超过10秒，那么master就不会对外提供服务了。
			
			
		* 哨兵模式：主从模式下，如果只有一个哨兵也是可以进行故障转移的。一般情况下都不会只有一个哨兵。
					单master的redis集群，sentinel一般配置三台，避免如果是单sentinel宕机以后无法提供故障转移操作。
					
					sentinel会通过心跳监控集群下的每一台服务，如果有redis服务在规定时间内没有返回给sentinel，这台sentinel会主观认为这台redis已经宕机了sdown
					如果超过sentinel.conf中配置的sentinel服务器个数认为redis服务器sdown了以后，这时sentinel系统会客观认为这台redis已经离线了，--> odown。
					如果这台redis是master，这个时候就会sentinel就会发起故障转移，从slave节点中推选出新的master节点，并把其他从节点挂在新推举出来的master下。
					
		* 集群模式：redis内置数据自动分片机制，集群内部将所有的key映射到16384(10 0000 0000 0000、2的14次方)个Slot中，集群中的每个redis instance负责其中的一
					部分的Slot的读写。
		
		
	4、slave-read-only在集群模式下的作用。
	
	
	5、集群脑裂问题。
	
	
	6、缓存过期策略。
	
	

##################################################################################################################################################################
###########################################################    	         附录				######################################################################
##################################################################################################################################################################
		
附录一：sentinel配置文件：
##################################################################################################################################################################
	# 当前Sentinel服务运行的端口
	port 26379

	# master
	# Sentinel去监视一个名为mymaster的主redis实例，这个主实例的IP地址为本机地址127.0.0.1，端口号为6379，
	# 而将这个主实例判断为失效至少需要2个 Sentinel进程的同意，只要同意Sentinel的数量不达标，自动failover就不会执行
	sentinel monitor mymaster 127.0.0.1 6379 1

	# 指定了Sentinel认为Redis实例已经失效所需的毫秒数。当实例超过该时间没有返回PING，或者直接返回错误，那么Sentinel将这个实例标记为主观下线。
	# 只有一个Sentinel进程将实例标记为主观下线并不一定会引起实例的自动故障迁移：只有在足够数量的Sentinel都将一个实例标记为主观下线之后，
	# 实例才会被标记为客观下线，这时自动故障迁移才会执行。
	sentinel down-after-milliseconds mymaster 5000

	# 指定了在执行故障转移时，最多可以有多少个从Redis实例在同步新的主实例，在从Redis实例较多的情况下这个数字越小，同步的时间越长，完成故障转移所需的时间就越长
	sentinel parallel-syncs mymaster 1

	# 如果在该时间（ms）内未能完成failover操作，则认为该failover失败
	sentinel failover-timeout mymaster 30000

	
	
附录二：查看哨兵模式的命令
#################################################################################################################################################################

	启动一个哨兵：redis-server.exe  ./sentinel.conf  --sentinel
	
	查看一个redis的状态： redis-cli.exe -h ip -p port
						  info replication
						  
								127.0.0.1:6377> info replication
								# Replication
								role:master
								connected_slaves:2
								slave0:ip=127.0.0.1,port=6378,state=online,offset=39590,lag=0
								slave1:ip=127.0.0.1,port=6379,state=online,offset=39590,lag=0
								master_repl_offset:39590
								repl_backlog_active:1
								repl_backlog_size:1048576
								repl_backlog_first_byte_offset:2
								repl_backlog_histlen:39589

								
附录三：redis.conf集群配置
#######################################################################################################################################################################################################################################
	# 如果配置yes则开启集群功能，此redis实例作为集群的一个节点，否则，它是一个普通的单一的redis实例。
	cluster-enabled yes
	
	# 虽然此配置的名字叫"集群配置文件"，但是此配置文件不能人工编辑，它是集群节点自动维护的文件，主要用于记录集群中有哪些节点、他们的状态以及一些持久化参数等，
	# 方便在重启时恢复这些状态。通常是在收到请求之后这个文件就会被更新。
	cluster-config-file cluster-6379.conf

	# 这是集群中的节点能够失联的最大时间，超过这个时间，该节点就会被认为故障。如果主节点超过这个时间还是不可达，则用它的从节点将启动故障迁移，升级成主节点。
	# 注意，任何一个节点在这个时间之内如果还是没有连上大部分的主节点，则此节点将停止接收任何请求。一般设置为15秒即可。
	cluster-node-timeout 15000

	# 如果设置成０，则无论从节点与主节点失联多久，从节点都会尝试升级成主节点。
	# 如果设置成正数，则cluster-node-timeout【乘】cluster-slave-validity-factor得到的时间，是从节点与主节点失联后，此从节点数据有效的最长时间，
	# 超过这个时间，从节点不会启动故障迁移。
	# 假设cluster-node-timeout=5，cluster-slave-validity-factor=10，则如果从节点跟主节点失联超过50秒，此从节点不能成为主节点。
	# 注意，如果此参数配置为非0，将可能出现由于某主节点失联却没有从节点能顶上的情况，从而导致集群不能正常工作，在这种情况下，
	# 只有等到原来的主节点重新回归到集群，集群才恢复运作。
	cluster-slave-validity-factor 10
	
	# 主节点需要的最小从节点数，只有达到这个数，主节点失败时，它从节点才会进行迁移。更详细介绍可以看本教程后面关于副本迁移到部分。
	cluster-migration-barrier 1
	
	# 在部分key所在的节点不可用时，如果此参数设置为"yes"(默认值), 则整个集群停止接受操作；如果此参数设置为”no”，则集群依然为可达节点上的key提供读操作
	cluster-require-full-coverage yes
	